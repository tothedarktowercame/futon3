@arg fulab/clock-in
@title Agent Clock-In
@sigils [üìé/clock-in]
! conclusion: Clock in first to establish the design-authorization anchor for this session.
  + context: An agent is about to start a task that will change a codebase or knowledge base.
  + if: You want the agent's work to be traceable, auditable, and explicitly linked to the design glossary.
  + however: Without an explicit declaration, the link between agent actions and design patterns stays implicit and hard to verify later.
  + then: Before substantive work starts, the agent emits a clock-in event that includes the primary pattern ID, intent description, and session context, declaring the design-authorization source for the session.
  + because: The clock-in event creates a non-optional anchor for the proof path, so later actions can be evaluated against the declared intent.
  + next-steps:
    - Check that every side-effecting event traces back to a prior clock-in; treat any side effect without clock-in as a violation.
    - evidence: src/f2/claude.clj - clock-in-event records :clock-in/session-id for audit linkage.
    - evidence: src/f2/codex.clj - clock-in-event now includes :clock-in/session-id for audit linkage.
    - evidence-shape: {:clock-in/pattern-id :string, :clock-in/intent :string, :clock-in/session-id :string, :clock-in/timestamp :inst, :clock-in/context :map}

@arg fulab/pattern-dep
@title Pattern Dependency Declaration
@sigils [üî∫/dep]
! conclusion: Make reasoning dependencies explicit so the proof path becomes a verifiable structure.
  + context: An agent is working under pattern P1 and needs to invoke reasoning from pattern P2 to complete the current step.
  + if: You want the proof path to capture compositional reasoning, not just a flat list of events.
  + however: If dependencies live only in internal thought and are not recorded, you cannot reconstruct the structural rationale for why a step is valid.
  + then: When an agent uses P2 reasoning in a P1 session, emit a pattern-dep event that declares the P1 -> P2 dependency edge with a brief reason.
  + because: Explicit dependencies model the proof path as a DAG, allowing each step's basis to be structurally verified.
  + next-steps:
    - Run DAG checks on dependency graphs per session (no cycles); sample dependency edges to confirm the reason is supported in cell/trace evidence.
    - evidence: src/f2/claude.clj - pattern-used-event supports optional :pattern/parent to declare dependency edges.
    - evidence: src/f2/claude.clj - pattern-used-event emits :pattern/dep for dependency edges.
    - evidence: src/f2/codex.clj - record-pattern-use! accepts :parent-id and emits :pattern/parent.
    - evidence: src/f2/claude.clj - record-pattern-use! now accepts :parent-id and records :pattern/parent for dependencies.
    - evidence: src/f2/codex.clj - pattern-used-event emits :pattern/dep for dependency edges.
    - evidence-shape: {:session/id :string, :pattern/parent :string, :pattern/dep :string, :pattern/reason :string, :used-at :inst}

@arg fulab/clock-out
@title Agent Clock-Out
@sigils [üåΩ/clock-out]
! conclusion: Seal the proof path and outputs with an explicit end event.
  + context: An agent finishes a unit of work and is ready to end the session with a checkable summary.
  + if: You want the session to end in a way that can be validated against the original intent, producing a sealable proof path.
  + however: Without a clear ending, the path is often incomplete (missing status, artifacts, dependency summary), making audit and replay difficult.
  + then: Before ending the session, the agent emits a clock-out event including the primary pattern, full dependency trail summary, completion status, and list of produced or modified artifacts.
  + because: The clock-out event seals the proof path with the minimal complete data needed for audit, replay, and progress tracking.
  + next-steps:
    - Verify that the clock-out pattern trail can be reconstructed from the session's clock-in + pattern-dep events; confirm artifacts match the actual change set.
    - evidence: src/f2/codex.clj - clock-out-event records :clock-out/session-id for closure linkage.
    - evidence: src/f2/claude.clj - clock-out-event records :clock-out/session-id for closure linkage.
    - evidence-shape: {:session/id :string, :pattern/primary :string, :pattern/trail [:map], :session/status :keyword, :artifacts [:string], :clock-out/timestamp :inst}

@arg fulab/proof-commit
@title Proof-Conformant Commit
@sigils [üèÉ/commit]
! conclusion: Constrain commits by proof paths to prevent unauthorized changes from reaching main.
  + context: An agent (or user) wants to commit changes produced during a clocked-in session to the codebase or knowledge base.
  + if: You want every commit to trace back to the design authorization and proof path that produced it.
  + however: Standard commits record what changed, not why the change was permitted.
  + then: Commits must reference a proof path (session-id + pattern trail); MUSN validates that the path satisfies pattern constraints and integrity checks (e.g., clock-in/clock-out present, DAG acyclic, required evidence complete) before accepting.
  + because: Commit checks are an enforcement point that prevents unauthorized changes from bypassing the design glossary.
  + next-steps:
    - Define a minimal validation rule set (existence, structure, correspondence); record failure types on each rejection to tune constraint strictness.
    - evidence: src/futon3/fulab/pattern_competence.clj - proof-commit-template captures validation envelope.
    - evidence: src/futon3/fulab/pattern_competence.clj - proof-commit-template stamps :commit/checked-at for validation timing.
    - evidence-shape: {:commit/changes :any, :commit/session-id :string, :commit/checked-at :inst, :commit/pattern-trail [:map], :commit/validation {:ok? :boolean, :errors [:map]}}
  + blocked-by: [fulab/clock-in, fulab/clock-out]

@arg fulab/notebook-cell
@title Live Notebook Cell
@sigils [üìÅ/cell]
! conclusion: Persist prompt/response exchanges and side effects in real time as cells.
  + context: During execution, an agent continuously exchanges prompts/responses with a model, and those exchanges trigger tool calls or file side effects.
  + if: You want the experiment notebook to grow in real time rather than be reconstructed afterward.
  + however: If records are captured only after the session ends, you lose streaming stats, partial failure states, and mid-session intent shifts.
  + then: Persist each prompt/response exchange as a notebook cell with input, output, time/cost/model metadata, and side effects (file IO, tool calls, external API traces); link the cell to the proof path via session-id.
  + because: Real-time capture preserves fine-grained timing and side-effect evidence and supports immediate integration with the evidence chain.
  + next-steps:
    - Sample-compare cell side effects with actual system events (file changes, command logs); test whether cells can reconstruct a simplified proof path.
    - evidence: src/futon3/fulab/pattern_competence.clj - notebook-cell-template mirrors cell evidence shape.
    - evidence: src/futon3/fulab/pattern_competence.clj - notebook-cell-template adds :cell/sequence for ordering.
    - evidence-shape: {:session/id :string, :cell/id :string, :cell/sequence :long, :cell/input :string, :cell/output :string, :cell/metadata {:model :string, :cost :map, :latency-ms :long}, :cell/side-effects [:map], :cell/timestamp :inst}

@arg fulab/session-resume
@title Session Resume
@sigils [üî¶/resume]
! conclusion: Maintain audit continuity across multi-turn conversations with explicit mapping and ancestor chains.
  + context: An agent needs to resume a prior conversation later to extend work or ask follow-ups within existing context.
  + if: You want multi-turn conversations with traceable continuity.
  + however: If each call is treated as stateless, the agent cannot reliably carry forward constraints, evidence, and intent changes.
  + then: Maintain a runtime registry mapping futon session-id to the external fucodex CLI session identifier; resume requests use that identifier (e.g., `--resume`) to continue the conversation, and a new session-id is created that references the ancestor session to preserve audit continuity.
  + because: Explicit mapping and ancestor references preserve conversation continuity while keeping audit boundaries clear.
  + next-steps:
    - Define whether resume allows switching the primary pattern key; test that the proof path ancestor chain remains consistently reconstructable after multiple resumes.
    - evidence: src/f2/codex.clj - session-started-event records :session/ancestor-id and :session/fucodex-cli-id when provided.
    - evidence: src/f2/codex.clj - resume-session! now stamps :ancestor-id from stored session mapping.
    - evidence: src/f2/codex.clj - resume-session! stamps :resume/at and :resume/count in opts.
    - evidence: src/f2/codex.clj - session-started-event includes :resume/at and :resume/count for resumed sessions.
    - evidence: src/f2/codex.clj - session-started-event records :resume/prompt for resumed sessions.
    - evidence-shape: {:session/id :string, :session/ancestor-id :string, :session/fucodex-cli-id :string, :resume/prompt :string, :resume/at :inst, :resume/count :long}
  + enables: [fulab/clock-in]

@arg fulab/pattern-propose
@title Agent Pattern Proposal
@sigils [‚û∞/propose]
! conclusion: Expand the pattern library based on implementation evidence.
  + context: During work, an agent discovers a recurring reasoning structure that isn't captured by existing patterns.
  + if: You want the pattern library to evolve based on lived practice, not just top-down design.
  + however: Agents cannot unilaterally add patterns to the canonical library.
  + then: The agent emits a pattern-proposal event with a draft IF/HOWEVER/THEN/BECAUSE structure, supporting evidence from the current trail, and a :draft status. Human stewards review proposals and promote to :accepted.
  + because: This closes the loop: patterns guide agent work, and agent work refines patterns. The library is a living document.
  + next-steps:
    - Require proposals to cite at least one supporting trail event and record reviewer notes on accept/reject outcomes.
    - evidence: src/futon3/fulab/pattern_competence.clj - added pattern-proposal-template for draft proposal structure.
    - evidence: src/futon3/fulab/pattern_competence.clj - proposal-claim-event emits proposal events.
    - evidence: src/futon3/fulab/pattern_competence.clj - proposal-claim-event stamps :proposal/claimed-at for review trace.
    - evidence: src/futon3/fulab/pattern_competence.clj - proposal template includes :proposal/reviewer-notes for review outcomes.
    - evidence-shape: {:proposal/id :uuid, :pattern/draft :map, :proposal/supporting-trail [:uuid], :proposal/status :keyword, :proposal/claimed-at :inst}
  + blocked-by: [fulab/clock-out]

@arg fulab/changelog-trail
@title Changelog-as-Trail
@sigils [üôá/trail]
! conclusion: Use manual records as a temporary proof trail while infrastructure catches up.
  + context: Before the full proof trail infrastructure exists, we need a way to simulate pattern-based work.
  + if: You want to dogfood the pattern architecture while building it.
  + however: XTDB persistence, MUSN enforcement, and check DSL aren't implemented yet.
  + then: Maintain a changelog file (e.g., fulab-changelog.org) where each entry explicitly records: clocked-in pattern, pattern dependencies used, artifacts produced, and clock-out summary. This serves as a human-readable proof trail.
  + because: The changelog simulates the architecture and provides a migration path - entries can be backfilled into XTDB once the infrastructure exists.
  + next-steps:
    - Add a fixed template per entry (clock-in, deps, artifacts, clock-out) and schedule a periodic backfill into XTDB once proof events land.
    - evidence: src/futon3/fulab/pattern_competence.clj - changelog-entry-template matches trail entry shape.
    - evidence: src/futon3/fulab/pattern_competence.clj - changelog-entry-template includes :entry/session-id for traceability.
    - evidence-shape: {:changelog/file :string, :entry/date :string, :entry/session-id :string, :entry/pattern-id :string, :entry/deps [:string], :entry/artifacts [:string], :entry/summary :string}
  + enables: [fulab/clock-in, fulab/clock-out, fulab/proof-commit]

@arg fulab/devmap-xref
@title Devmap Cross-Reference
@sigils [üî∏/xref]
! conclusion: Create a traceable mapping between implementation patterns and devmap prototypes.
  + context: FuLab patterns are implementation-level; devmap prototypes are design-level.
  + if: You want to track how implementation work advances the higher-level devmap.
  + however: The connection between fulab patterns and devmap prototypes is implicit.
  + then: Each fulab pattern declares which devmap prototype(s) it supports via a :pattern-ref field. Clock-in events that reference a fulab pattern transitively reference the devmap. Rollups can show "Prototype 4 advanced by 3 fulab/clock-out events today."
  + because: This creates a traceable ladder from daily work -> fulab patterns -> devmap prototypes -> IFR.
  + next-steps:
    - Require every fulab pattern to include a :pattern-ref and validate that referenced devmap files/clauses exist.
    - evidence: src/futon3/fulab/pattern_competence.clj - devmap-xref-template captures :pattern-ref targets.
    - evidence: src/futon3/fulab/pattern_competence.clj - devmap-xref-template adds :devmap-clause for clause linkage.
    - evidence: src/futon3/fulab/hud.clj - HUD candidates include :pattern-ref in prompt output.
    - evidence-shape: {:fulab-pattern :string, :devmap-prototype :string, :devmap-file :string, :devmap-clause :string}

@arg fulab/blast-radius
@title Blast Radius Control
@sigils [üßØ/blast]
! conclusion: Define the failure impact boundary and the minimal rollback plan.
  + context: A change or tool action could impact multiple subsystems or teams.
  + if: You want failures to remain localized and diagnosable without full rollback.
  + however: Without a declared blast radius, incident response defaults to broad freezes or guesswork.
  + then: Emit a blast-radius event before risky actions, naming affected surfaces, rollback scope, and detection signals; record the outcome on clock-out.
  + because: Declared boundaries shorten diagnosis time and reduce collateral damage.
  + next-steps:
    - Require blast-radius events for cross-futon changes; audit that the rollback scope matches actual artifacts.
    - evidence: src/futon3/fulab/pattern_competence.clj - blast-radius-template matches event fields.
    - evidence: src/futon3/fulab/pattern_competence.clj - blast-radius-template includes :blast/notes for rollback rationale.
    - evidence-shape: {:session/id :string, :blast/surfaces [:string], :blast/rollback [:string], :blast/detectors [:string], :blast/risk :keyword, :blast/notes :string}

@arg fulab/tradeoff-record
@title Trade-off Record
@sigils [‚öñÔ∏è/trade]
! conclusion: Use explicit assumptions and trade-offs to improve decision quality and reduce churn.
  + context: A decision requires trading off speed, correctness, scope, or risk.
  + if: You want later reviewers to understand the decision without re-deriving it.
  + however: Hidden trade-offs cause churn when requirements change or audits occur.
  + then: Emit a tradeoff-record event listing options considered, assumptions, chosen rationale, and reversal triggers.
  + because: Explicit trade-offs improve reviewability and guide future reversals.
  + next-steps:
    - Require at least one tradeoff-record when a scope or risk change is accepted.
    - evidence: src/futon3/fulab/pattern_competence.clj - tradeoff-record-template captures decision fields.
    - evidence: src/futon3/fulab/pattern_competence.clj - tradeoff-record-template stamps :decision/recorded-at.
    - evidence-shape: {:session/id :string, :decision/id :string, :decision/recorded-at :inst, :decision/options [:string], :decision/assumptions [:string], :decision/rationale :string, :decision/reversal-triggers [:string]}
