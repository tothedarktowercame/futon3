@multiarg futon3/devmap
@title FUTON3 Development Map
@audience futon-devs, sandbox-agents, future-you
@tone formal-analytic
@style roadmap
@allow-new-claims true
@length any
@factor Joy / Rapture (pÄ«ti)
@IFR: FUTON3 is the place where the system turns messy activity into organised knowledge.
It collects what happens, checks it against a library of shared patterns, and produces clear, trustworthy records that other futons can use to learn, improve, and act.  FUTON3 makes everyday work auditable, meaningful, and easier to build on.

@state Transport runs reliably, events are logged, and patterns can be checked.
Tatami sessions already feed structured evidence downstream, but that evidence
does not yet flow back into pattern updates or storage-backed history. We have
an early pattern catalog, working embeddings, and a first version of the
workday pipeline. What remains is tightening those links â€” coupling Tatami
evidence into pattern updates, tying checks into storage, producing clearer
histories, and building the stable interfaces that other futons can depend on
for coordinated reasoning.

@next Stand up the completed pattern canon + `check!` API, standardise proofâ†’graph/energy exports, and land the workday instrumentation + trail rollups as first-class MUSN services before expanding the flexiformal training ground.

! instantiated-by: Prototype 0 â€” Flexiformal Transport Baseline [ğŸƒ/ç´¢ â°/æ°]
  + context: FUTON3 still rides the MUSN transport (WS+HTTP bus, SAFE/ADMIN REPL, NDJSON ingest), but its primary job is to host pattern checks and informal proof states, not free-roaming agents.
  + if: You want an execution substrate where pattern obligations can be posed, evaluated, and recorded with deterministic transcripts.
  + however: The baseline hello/event/session flows are documented as â€œnon-essential documentationâ€ instead of â€œproofwork IO contracts.â€
  + then: Freeze the transport contract from the perspective of check jobs (pattern-apply, gap-report, trail-capture), provide golden transcripts for each, and version the `sandbox` profile (i.e., how to work with patterns via the safe MUSN transport) as the canonical proofwork runtime.
  + because: Flexiformal checking needs a stable log format before any higher-layer reasoning can rely on it.
  + evidence: docs/protocol.md, src/f2/router.clj, test/f2/router_test.clj (100-event idempotency + export/run/status acceptance), and test/transport_test.clj (per-client disconnect logging).
  + next-evidence:
    - {:type :Spec :id "transport-contract-check-jobs-v1" :description "Define a frozen transport contract for pattern-apply, gap-report, and trail-capture jobs including message shapes, sequencing, and log guarantees." :acceptance-criteria ["Spec enumerates request/response schemas, NDJSON log records, and required invariants for all three check jobs." "Fails if there is no reliable A->B association between proposal and evidence collection; must be machine-checkable now and upgradeable for stronger logics later."] :suggested-location "docs/protocol/transport-contract-v1.md" :timebox "2026-01-05"}
    - {:type :Spec :id "golden-transcripts-check-jobs" :description "Specify canonical golden transcripts for pattern-apply, gap-report, and trail-capture runs that deterministically exercise the frozen transport contract." :acceptance-criteria ["Each transcript is reproducible from the sandbox profile and matches byte-for-byte expected NDJSON output." "Fails if there is no reliable A->B association between proposal and evidence collection; must be machine-checkable now and upgradeable for stronger logics later."] :suggested-location "docs/protocol/golden-transcripts.md" :timebox "2026-01-05"}
    - {:type :Spec :id "sandbox-profile-proofwork-runtime" :description "Document the sandbox profile as the canonical proofwork runtime and explain how to execute check jobs from the Clojure runner." :acceptance-criteria ["Spec explains sandbox configuration, versioning rules, and step-by-step runner commands tied to transcript generation." "Fails if there is no reliable A->B association between proposal and evidence collection (i.e., we need a clear and deterministic correspondence between anticedents A and measurable evidence B); must be machine-checkable now and upgradeable for stronger logics later."] :suggested-location "docs/sandbox/README.md" :timebox "2026-01-05"}

! instantiated-by: Prototype 1 â€” Pattern Canon & Standard Library [ğŸ—¿/æœ¬]
  + context: A small flexiarg/pattern library already exists (Nonstarter, Proto/Allow-Works, etc.) but is scattered between files.
  + if: You want FUTON3 to be the place where patterns are curated with metadata, linking obligations, and proof status.
  + however: There is no standardized repository or schema for â€œpattern definitions + applicability notes + links to Futon devmaps.â€
  + then: Stand up a `f3.patterns` store (ID, clauses, references, pÄramitÄ tags, fruits/orbs weights) populated with the current standard library and backfilled with source links.  The pattern store should be addressible/interactable from across the stack.  So, it should use futon1 storage, with contents feature comple with the filesystem devmaps and library, which provide a "checked out working copy"; the store needs to be easy to maintain relative to these checked out copies.  Patterns managed by the store should be inspectable, linkable, and editable with Arxana (futon4), and subject to ongoing improvement via aob-chatgpt (futon3).
  + because: Without a canonical pattern store, the checker has nothing trustworthy to compare against: our understanding of "inference" is based on associations between the "if/however â†’ then" inside patterns: we need to be able to check any action that's made relative to the codebase against these patterns to know if it counts as progress.
  + evidence: We have an a basic working version of the store in futon1, including ingest. `resources/pattern_store.edn`, `src/futon3/pattern_store.clj`, and `test/pattern_store_test.clj` keep the catalog synced with live tests + README references.
  + next-evidence:
    - {:type :Golden :id "pattern-store-loads-and-enumerates" :description "A golden test proves the f3.patterns store can be loaded at runtime and enumerates all canonical pattern IDs." :acceptance-criteria ["Loading the pattern store via the public Futon3 API returns a non-empty, stable set of pattern IDs matching the standard library inventory." "Fails if the canonical store only exists on disk and is not accessible to the stack."] :suggested-location "test/futon3/pattern_store_golden_test.clj" :timebox "2026-01-06"}
    - {:type :Golden :id "pattern-metadata-and-links-complete" :description "A golden test asserts that each canonical pattern includes required metadata fields and valid source or devmap links." :acceptance-criteria ["Every pattern entry exposes ID, clauses, references, pÄramitÄ tags, fruits/orbs weights, and at least one resolvable source link." "Fails if the canonical store only exists on disk and is not accessible to the stack."] :suggested-location "test/futon3/pattern_metadata_golden_test.clj" :timebox "2026-01-06"}
    - {:type :Golden :id "pattern-store-matches-standard-library" :description "A golden test verifies that all patterns from the existing standard library are present in f3.patterns with no omissions." :acceptance-criteria ["The set of patterns in f3.patterns exactly matches the known Nonstarter and Proto/Allow-Works library with no missing or extra entries." "Fails if the canonical store only exists on disk and is not accessible to the stack."] :suggested-location "test/futon3/pattern_library_sync_golden_test.clj" :timebox "2026-01-06"}

! instantiated-by: Prototype 1b â€” Live REPL Surface Validation (Drawbridge) [ğŸª¢/æ¡¥ ğŸ§ª/éªŒ]
  + context: Futon3 already exposes an optional Drawbridge REPL over HTTP, but we have not documented or exercised a live-in-server workflow the way Emacs users rely on emacsclient.
  + if: You want to use Codex (or a human operator) to connect to a running Futon3 instance and safely poke at the live system state for inspection and debugging.
  + however: The REPL is off by default, and there is no canonical checklist proving that a Drawbridge session can connect, query MUSN state, and execute a minimal set of safe operations.
  + then: Validate the Drawbridge workflow against a running Futon3 server: enable Drawbridge, connect via a REPL client, and execute a small script that queries `musn.api/*` functions (clients/history/links/now), verifies read-only access, and records a short transcript in the logs/docs.
  + because: A proven live REPL workflow is the smallest step toward unified Clojure-stack introspection and gives Codex a reliable surface for in-server exploration.
  + evidence:
    - `README.md` (Drawbridge section) documents enabling the HTTP REPL and connecting from Emacs/CIDER.
  + next-evidence:
    - {:type :Checklist :id "drawbridge-repl-live-session" :description "Checklist proving Drawbridge can connect to a running Futon3 instance and execute a minimal safe query script." :acceptance-criteria ["Drawbridge enabled with a local-only token; CIDER connects over HTTP and evaluates `(musn.api/clients)` / `(musn.api/history)` without errors." "Transcript saved in `docs/` or `logs/` with timestamp and server config used."] :suggested-location "docs/repl/drawbridge-session.md" :timebox "2026-01-12"}

! instantiated-by: Prototype 2 â€” Similarity Field & Fake Embedding [ğŸŒ‚/ç”² ğŸ‘‚/è·]
  + context: We already use a â€œfake embeddingâ€ (sigil adjacency) to find nearby patterns.
  + if: You want reproducible neighbourhood queries for pattern suggestions.
  + however: The embedding lives in ad-hoc CSVs and isnâ€™t wired into FUTON3â€™s APIs.
  + then: Integrate the sigil-distance matrix into FUTON3 as a first-class service (pattern search API, `nearest-patterns` command, CLI/UI views) and publish tests proving deterministic neighbourhoods.
  + because: Pattern suggestion quality underpins the flexiformal workflow and must be inspectable.

! instantiated-by: Prototype 3 â€” Applicability Engine & Check DSL [ğŸŒ½/æœ« ğŸ‘/åˆ¤]
  + context: We want FUTON3 to answer â€œcan this pattern apply?â€ and â€œwhat new obligations arise?â€
  + if: You want a declarative DSL (possibly REPL-safe) for posing check contexts and receiving structured verdicts (applies / blocked / missing evidence).
  + however: Checks today are conversational heuristics in aob-chatgpt or handwritten flexiargs.
  + then: Define a `check!` API (inputs: pattern ID, context EDN, evidence refs; outputs: status, missing fields, derived tasks), enforce schema validation, and log every check as a proof state record.
  + because: Turning patterns into executable checks is what makes FUTON3 â€œflexiformalâ€ rather than just narrative.
  + next: Ship the Futon1/Futon2 adapters so `futon3/logs/checks.edn` entries replicate into graph + viriya stores instead of living only in local logs, and expose `/musn/check` over HTTP once the transport contract is frozen.
  + evidence: `src/futon3/checks.clj`, `src/f2/router.clj`, `src/f2/transport.clj`
    (Futon1 bridge wiring), `src/futon3/futon1_bridge.clj`, and
    `test/transport_test.clj` (workday/check forwarding cases) exercise the DSL
    end-to-end.

! instantiated-by: Prototype 4 â€” Trail & Proof-State Journal [â°/åŒ]
  + context: Wisdom trails already exist for tracing exploration, but now they must document proof obligations and how work sessions discharged them.
  + if: You want every check, dismissal, and new pattern idea to leave an auditable trail.
  + however: Trails are still general-purpose exploration logs, not proof-state journals.
  + then: Extend the trail schema with `:pattern/id`, `:obligation/id`, `:action/tags`, and `:delta/joy`, add rollups that show which devmap clauses advanced per day, and expose a `/musn/trails/proof` export for futon4 archives.
  + because: The whole point is to measure how daily practice advances the devmaps.
  + design: The Tatami HUD cue-reflection pattern mirrors every FROM-CHATGPT entry back through `/musn/cues` so fruits/orbs in the HUD match the transportâ€™s cue embedding (`contrib/aob-chatgpt.el:1503`, `src/f2/ui.clj:97`, `src/futon3/cue_embedding.clj:214`).
  + evidence: `resources/tatami-events.edn` captures live tatami sessions, `resources/tatami-context.edn` logs every FROM-CHATGPT-EDN HUD payload, and the cue embedding tests (`test/futon3/cue_embedding_test.clj`) prove keyword/intentionally-null payloads round-trip.
  + blocked-by [:trail/persistence :cue-validation]
  + next: (1) persist cue annotations into the trail export so Prototypeâ€¯4 records which fruits/orbs were actually computed, and (2) add proof artifacts (HUD screenshots or `/musn/cues` transcripts) that demonstrate the cues signal real changes instead of static defaults before declaring the prototype stable.

! instantiated-by: Prototype 4b â€” Intent Embedding & Salience Map [â°/æ° ğŸ/åŠ]
  + context: Prototype 4 turns trails into proof-state journals, but it still treats fruits/orbs as cosmetic tags instead of Kolmogorov-style proof types for each constructive step.
  + if: You want the HUD to say not just â€œsomething happened hereâ€ but â€œthis was an indicator check, and it was (or wasnâ€™t) aligned with your valuesâ€ â€” i.e. to classify `intent â†’ pattern reasoning` as typed proof steps like ğŸŒâ†’ğŸ”µ rather than anonymous log lines.
  + however: The current trail schema records `:pattern/id` and `:obligation/id` but has no machinery to interpret `intent â†’ pattern reasoning` as a constructive proof step, embed it in fruit/orb space, and ask â€œwhat kind of operator was this?â€ (fruit) and â€œwhat meta-property did it exhibit?â€ (orb) â€” e.g. â€œğŸŒ: indicator construction, ğŸ”µ: virtue-alignedâ€.
  + then: Define a futon3 embedding pipeline that maps each `:trail/intent` plus `:pattern/reasoning` tuple into a low-dimensional vector, projects that vector onto a (fruit, orb) pair understood as (operator-class, meta-property), and computes a `:rule/salience` score from structural, pragmatic, and reflective components; write `:fruit/id`, `:orb/id`, and `:rule/salience` back onto the trail events so Prototype 4 can roll up â€œwhich devmap clauses advanced, via which kinds of proof step (e.g. ğŸŒ indicator definition or check, ğŸ’ simple inference, ğŸŠ breakdown into a proof plan, etc.), and how strongly they matteredâ€ per day.
  + because: In Kolmogorovâ€™s sense, a proof is a construction of an object; here, each trail step is a constructive proof step that builds a pattern-typed object whose canonical form is its (fruit, orb) type. Typing steps like â€œğŸŒâ†’ğŸ”µâ€ lets you distinguish â€œthis is just a checkâ€ from â€œthis is an indicator that actually preserves the virtue invariant,â€ and salience separates merely valid rules from those that are central to your meta-theory in practice.
  + design: Implement `futon3.intent-embedding/intent->vec` to encode `:trail/intent` + `:pattern/reasoning` as a vector, `futon3.intent-embedding/vec->fruit+orb` to pick the nearest (fruit, orb) type under a basis where fruits encode proof operator classes (e.g. ğŸŒ = indicator/check, ğŸ = invariant-preserving step) and orbs encode meta-properties (e.g. ğŸ”µ = value-aligned / virtue-preserving, ğŸŸ  = boundary-discernment); define `futon3.intent-embedding/vec->salience` to combine geometric proximity to an â€œidealâ€ direction for each (fruit, orb) type with usage frequency and an optional reflective score. Extend the trail export with `:fruit/id`, `:orb/id`, `:rule/salience`, and add HUD affordances so Tatami can sort, filter, or highlight proof-state entries by their typed role (e.g. all ğŸŒâ†’ğŸ”µ value-aligned checks) instead of just by timestamp.
  + evidence: Early Cue Embedding tests (`test/futon3/cue_embedding_test.clj`) already show that keyword payloads round-trip through the embedding; hand-labelled fruit/orb assignments in `resources/paramita-grid.edn` provide a gold set for checking whether `vec->fruit+orb` recovers the expected operator/meta-property types on known patterns, including basic Komolgorov relations like â€œindicator-construction steps that should land in the ğŸ”µ virtue bandâ€.
  + next: (1) Generalise the existing cue embedding to operate on `:trail/intent` + `:pattern/reasoning` tuples and return (fruit, orb) as proof step types, (2) run a calibration pass over a small set of manually typed patterns to tune the fruit/orb basis and salience weights, ensuring that canonical relations like ğŸŒâ†’ğŸ”µ (â€œvalue-aligned indicator checksâ€) land in the intended region, and (3) wire the enriched trail export into Prototype 4â€™s rollups so devmap progress can be inspected as â€œwhich constructive proof-types actually fired today, how salient they were, and whether the checks that claimed to align with your values really did so in the embedding.â€

! instantiated-by: Prototype 5 â€” Workday Instrumentation & aob-chatgpt Bridge [ğŸ’¤/æ¯]
  + context: Within `aob-chatgpt` we already experiment with reflecting on daily actions against devmap obligations.
  + if: You want FUTON3 to serve as the backend for those reflections.
  + however: There is no official API for submitting â€œworkday claims,â€ mapping them to patterns, or receiving verification feedback; roles of â€œworkday participantsâ€ and â€œinstrumentation stewardsâ€ are undefined.
  + then: Publish a `workday/submit` endpoint (inputs: timestamp, activity, evidence links), run it through the check DSL + embedding, respond with pattern hits/misses plus follow-up obligations, and name the actors explicitly (participants supply evidence; instrumentation stewards curate dashboards); integrate the same flow into the ChatGPT tooling.
  + because: This is how empowered action (â€œjoyâ€) becomes measurable proof progress and how role responsibilities stay legible.
  + next: Replace the temporary `futon3/logs/workday.edn` queue with a Futon1 persistence call (`workday->graph`) and add HTTP affordances + dashboards so instrumentation stewards can audit submissions without tailing logs.
  + evidence: Workday intake lives in `src/futon3/workday.clj` with coverage in `test/transport_test.clj` (workday submission) and README sections describing the API.

! instantiated-by: Prototype 6 â€” Pattern Creation Workbench [ğŸ‘/å·²]
  + context: New patterns emerge from trails and devmap edits, but the capture is currently manual in futon4.
  + if: You want FUTON3 to draft candidate patterns/flexiargs from accumulated proof states.
  + however: Manual backlog in FUTON4 creates tension; there is no readiness window for when drafts are â€œhand-off ready.â€
  + then: Build a summariser that clusters trails, extracts hooks, and emits draft flexiarg blocks (IF/HOWEVER/THEN/BECAUSE) tagged with suggested pÄramitÄ, ready for futon4 editors, and declare readiness criteria (e.g., at least N supporting checks + steward review) so handoffs are predictable.
  + because: FUTON3 should not just consume the library; it should propose expansions grounded in lived work while signalling when drafts can be trusted.

! instantiated-by: Prototype 7 â€” Joy-as-Empowered-Action Metrics [âŒ›ï¸/åŠ› âš¡ï¸/æ¯]
  + context: Joy here = Spinozan increase in power to act, evidenced by commitments you can now keep.
  + if: You want metrics that show whether checks are empowering or draining.
  + however: Current â€œjoy metricsâ€ counted UI friction; they did not measure proofs discharged or obligations unblocked.
  + then: Track `time-to-proof`, `obligations-cleared`, `follow-on commitments`, and `viriya linkages` per session, and visualise them alongside subjective notes.
  + because: Empowered action is the KPI for this futon.

! instantiated-by: Prototype 8 â€” futon2/futon1 Proof Hooks [âš¡ï¸/äºŒ ğŸ‘/å·²]
  + context: FUTON3 already generates proof states; FUTON1 (graph) and FUTON2 (energy) need those proofs as fuel.
  + if: You want every accepted check to become a graph relation and a viriya delta without manual glue.
  + however: today the exports are bespoke Clerk notebooks or one-off scripts.
  + then: standardise two adaptersâ€”`proof->graph` (materialise relations with provenance) and `proof->energy` (emit activation deltas for futon2 dashboards)â€”and lock them with fixtures + schemas.
  + because: proofs only matter when other futons can act on them automatically.
  + next: Wire the Tatami event log into FUTON1 (per `futon3/tatami_store.clj` TODO) so session events flow into graph-memory before we expose the adapters.

! instantiated-by: Prototype 9 â€” Proof Training Ground ("Flexiformal Agent Sandbox") [ğŸš¢/æ° ğŸƒ/æœª]
  + context: FUTON3 needs a reproducible training ground where humans and agents can practice flexiformal checks before contributing to FUTON6.
  + if: You want collaborators (including FUTON6 math stewards) to experience the proof workflow hands-on.
  + however: README/docs still emphasise ants and MUD metaphors and do not ship a simulator/tutorial bundle; roles (training facilitators vs. FUTON6 learners) and release readiness are not declared.
  + then: Package a "Flexiformal Training Ground" release: updated README, tutorials referencing `t4r/` training patterns, sample check sessions, and a minimal simulator that feeds FUTON6's Hyperreal entries; name facilitators (FUTON3 maintainers) and consumers (FUTON6 trainees), and publish readiness criteria (tutorials complete, simulator recorded, onboarding docs updated) before tagging the release.
  + because: Storytelling plus an explicit training ground turns FUTON3 into a reproducible service that upstream layers (FUTON6, FUTON7) can consume and steward.
  + next: Aggregate Tatami session proof events into `proof-chain.edn` (per `tatami_store.clj` TODO) so the training ground exports persistent transcripts.

! instantiated-by: Prototype 10 â€” System Self-Description & Machine-Readable Manifest [ğŸ”ƒ/æœ¬ ğŸ“‹/ç³»ç»Ÿ]
  + context: The stack currently has documentation and APIs at various layersâ€”Futon1's storage API with checked invariants, Emacs Lisp functions callable via emacsclient, HTTP/WebSocket endpoints in Futon3. But these exist as separate artifacts: code, docs, and schemas that humans must correlate.
  + if: You want the system to describe itself in a way that agents can query, and for that description to stay synchronized with implementation.
  + however: No machine-readable manifest exists where components are first-class entities in the hypergraph. Patterns describe design structures but not system capabilities.
  + then: Unify documentation and APIs into a machine-readable manifest where stack components are first-class entities in Futon1. Patterns describe not just design structures but system capabilitiesâ€”what the message bus can do, what functions the Emacs interface exposes, what invariants each layer enforces. Enable agents to query the system about its own capabilities, and self-verify that the running system matches its declared structure.
  + because: This closes the reflexivity loop: a semantic network that includes a model of itself. FUTON3's pattern checker already validates its own devmap; extending this to describe the full stack enables ongoing self-documentation as the system extends. The machinery from F5 (patterns â†’ schema â†’ code) applies reflexively: the stack itself becomes a domain.
  + evidence:
    - `futon4/docs/evidence/rc-1.1-evidence.edn` seeds a machine-readable claim map for Futon0â€“Futon4.
  + next:
    - Expand the evidence map into a manifest schema (components, interfaces, invariants) and ingest it into Futon1 for queryable self-description.
