@multiarg futon1/devmap
@title FUTON1 Development Map ‚Äî Deterministic Storage Substrate
@audience futon-devs, infra-agents, future-you
@tone formal-analytic
@style roadmap
@factor Keen investigation (dhammavicaya)
@IFR: FUTON1 provides a deterministic, storage-oriented substrate that maintains
a coherent graph of facts across sessions. It keeps Datascript (fast) and XTDB
(persistent) in reproducible alignment so that the same world state appears
reliably across restarts and environments. It exposes a minimal CLI and HTTP
surface for ingesting text, inspecting entities and relations, and emitting
stable summaries‚Äîsuch as focus headers‚Äîthat downstream code can depend on
without embedding persistence or orchestration logic.
@state API settled with evolution protocols; invariant enforcement active;
hydration settled; graph-memory and NLP interface operational; open-world
ingest working; query workflows developing (cross-ref futon3a); pilot storage
partly implemented (fulab), MMCA storage planned.
@next Stabilize invariant coverage; expand pilot storage for MMCA experiments;
deepen futon3a query integration.

## The Argument

FUTON1 provides a deterministic, storage-oriented substrate that maintains a
coherent graph of facts across sessions. It exposes an HTTP API as the canonical
interface‚Äîsettled, with protocols for evolution‚Äîthrough which external tools
query and update the persistent store. Invariants are enforced as real
invariants: any violation is a "stop the line" moment that prevents silent
corruption. Graph-memory defines the core schema‚Äîentities, relations, salience
metadata‚Äîand coordinates mirroring between Datascript (fast) and XTDB
(persistent) so the same world state appears reliably across restarts. The NLP
interface provides deterministic tokenization and tagging that all ingest paths
depend on. XTDB hydration restores state on boot, with fallback to legacy
log+snapshot when XTDB is disabled. Open-world ingest allows background
knowledge to accumulate outside interactive sessions while sharing the same
persistent store. Query workflows make the stored graph inspectable; futon3a
develops complementary patterns for retrieval. Storage for pilots supports
experimental workflows‚Äîfulab runs are partly implemented; MMCA experiment
storage is planned.


! instantiated-by: Prototype 0 ‚Äî HTTP API (Canonical Interface) [üåè/Âèä üì§/Âèä]
  :maturity :settled
  :depends-on []
  :evidence-for-settled [API in daily use for 90+ days; evolution protocols documented]

  + context: The HTTP API is the canonical interface to FUTON1.
  + IF: External tools need to query and update the persistent store
  + HOWEVER: Without a stable API, clients must embed internal assumptions or scrape CLI output
  + THEN: Expose a minimal, documented HTTP surface for submitting utterances, inspecting state, and retrieving deterministic summaries (focus headers)
  + BECAUSE: A settled API lets higher futons and external tools depend on FUTON1 without coupling to internals

  + EVIDENCE:
    evidence[apps/api module implements HTTP endpoints via command-service]
    evidence[/api/alpha/meta/model/registry exposes live model descriptors]
    evidence[Focus headers and entity summaries emitted through same service as CLI]
    evidence[XTDB-backed state consistent across CLI and API surfaces]

  + NEXT-STEPS:
    next[Document evolution protocol for API versioning]
    next[Add /api/alpha/entities/latest?type=... for efficient recent-entity queries]
    next[Ensure clients omitting profile config resolve to documented default]

  :success-criteria
    pass[API responses remain stable across tagged versions]
    pass[External clients can query and update graph without internal knowledge]
    pass[/status surface shows resolved datastore path and config]
    fail[Breaking changes without version bump or migration path]

  :psr-example "Selected HTTP API for futon3a integration because it's the canonical FUTON1 interface"
  :pur-template "Used API endpoint {{endpoint}}, response time: {{ms}}ms, status: {{success|error}}"


! instantiated-by: Prototype 1 ‚Äî XTDB Hydration [üåä/Ê∞¥ üîÉ/Âèç]
  :maturity :settled
  :depends-on [f1/P3]
  :evidence-for-settled [Hydration verified across 100+ restart cycles; fallback to legacy tested]

  + context: XTDB hydration restores world state on boot.
  + IF: Sessions must resume with the same state they ended with
  + HOWEVER: Without reliable hydration, restarts lose or corrupt state
  + THEN: Hydrate from XTDB on boot, with fallback to legacy log+snapshot when XTDB is disabled
  + BECAUSE: Settled hydration makes FUTON1 a durable substrate, not just a session-scoped cache

  + EVIDENCE:
    evidence[Sessions hydrate from XT on boot]
    evidence[Fallback to legacy log+snapshot when XTDB disabled]
    evidence[Salience-survives-restart demonstration is canonical hydration test]
    evidence[-M:storage/inspect demonstrates reproducible hydration]

  + NEXT-STEPS:
    next[Document hydration sequence in storage reference]
    next[Add hydration timing telemetry]

  :success-criteria
    pass[State after hydration matches state before shutdown]
    pass[Fallback engages correctly when XTDB unavailable]
    pass[Hydration completes within reasonable time bounds]
    fail[State loss or corruption across restart]

  :psr-example "Selected XTDB hydration for session continuity because durability requires reliable restore"
  :pur-template "Hydration from {{source}}, entities loaded: {{count}}, duration: {{ms}}ms"


! instantiated-by: Prototype 2 ‚Äî Invariant Enforcement [üëâ/Ê≠¢ üòÑ/Ê≠£]
  :maturity :active
  :depends-on [f1/P0]
  :evidence-for-settled [Zero silent corruptions over 60+ days; all invariant violations logged and halted]

  + context: Invariants must be real invariants, not suggestions.
  + IF: The storage substrate promises determinism and consistency
  + HOWEVER: Without enforcement, violations can corrupt state silently
  + THEN: Treat invariant violations as "stop the line" moments‚Äîhalt processing, log the violation, prevent silent corruption
  + BECAUSE: A deterministic substrate is only trustworthy if invariants are actually enforced

  + EVIDENCE:
    evidence[Open-world invariants pass end-to-end including stub detection and relation type registration]
    evidence[CI green on Futon1 Deterministic Stack tests]
    evidence[Invariant failures halt processing rather than continuing with corrupt state]

  + NEXT-STEPS:
    next[Audit remaining invariant coverage gaps]
    next[Add invariant violation telemetry for monitoring]
    next[Document invariant categories and their enforcement points]

  :success-criteria
    pass[Any invariant violation halts processing immediately]
    pass[Violations are logged with sufficient context for diagnosis]
    pass[No silent corruption reaches persistent store]
    fail[Invariant violation proceeds without halt or log]

  :psr-example "Selected invariant-enforcement for storage integrity because silent corruption is unacceptable"
  :pur-template "Invariant check {{invariant-id}}, result: {{pass|halt}}, context: {{details}}"


! instantiated-by: Prototype 3 ‚Äî Graph-Memory Schema & Mirroring [üçµ/Êñá üîÉ/Âèç]
  :maturity :active
  :depends-on []
  :evidence-for-settled [Schema stable for 90+ days; mirroring verified across restart cycles]

  + context: Graph-memory is the core data model for FUTON1.
  + IF: FUTON1 must maintain a coherent fact graph across sessions
  + HOWEVER: Without a clear schema and mirroring contract, clients cannot rely on stored state
  + THEN: Define entity/relation schema, salience metadata, and Datascript‚ÜîXTDB mirroring rules as a documented contract
  + BECAUSE: A clear graph-memory contract turns internal storage into a reliable interface

  + EVIDENCE:
    evidence[apps/graph-memory defines Datascript schema and XTDB touchpoints]
    evidence[Test suites exercise persistence and salience fields]
    evidence[XT inspection paths demonstrate entity/relation document storage and reload]
    evidence[README documents schema, hydration behaviour, and mirroring]

  + NEXT-STEPS:
    next[Extract core graph-memory operations as named public API]
    next[Document which document types and fields are mirrored into XTDB]
    next[Describe expected seed graph in module README]
    next[Add migration notes for any schema changes]

  :success-criteria
    pass[Schema changes follow documented migration protocol]
    pass[Mirroring produces identical state in Datascript and XTDB]
    pass[External tools can query graph using documented shapes]
    fail[Schema drift between Datascript and XTDB representations]

  :psr-example "Selected graph-memory for entity storage because it defines FUTON1's core data model"
  :pur-template "Graph operation {{op}}, entities affected: {{count}}, mirrored: {{yes|no}}"


! instantiated-by: Prototype 4 ‚Äî NLP Interface [üìÅ/‰πâ üé¥/Âç∞]
  :maturity :active
  :depends-on []
  :evidence-for-settled [Deterministic outputs verified across 50+ test fixtures]

  + context: The NLP interface provides deterministic text processing.
  + IF: All ingest paths need consistent tokenization and tagging
  + HOWEVER: Without a clear pipeline, NLP behaviour is implicit in code
  + THEN: Expose tokenise ‚Üí tag ‚Üí chunk ‚Üí recognise as documented stages with testable outputs
  + BECAUSE: Deterministic NLP is the foundation for reproducible graph construction

  + EVIDENCE:
    evidence[apps/nlp-interface provides deterministic NER/POS tagging]
    evidence[Pattern-recognition hooks used across ingest and demo/client workflows]
    evidence[Test runners exist for NLP fixtures]
    evidence[README describes deterministic behaviour and shared pipeline usage]

  + NEXT-STEPS:
    next[Document pipeline stages as public API]
    next[Expand tests to cover each stage independently]
    next[Clarify expected input/output shapes for each stage]

  :success-criteria
    pass[Same input produces identical NLP output across runs and environments]
    pass[Pipeline stages are independently testable]
    pass[Upstream components agree on API usage]
    fail[NLP output varies non-deterministically]

  :psr-example "Selected nlp-interface for text processing because deterministic tagging is foundational"
  :pur-template "NLP processed {{char-count}} chars, entities: {{entity-count}}, deterministic: {{yes|no}}"


! instantiated-by: Prototype 5 ‚Äî Open-World Ingest [üì•/ÂÖ• üåè/ÂºÄ]
  :maturity :active
  :depends-on [f1/P3, f1/P4]
  :evidence-for-settled [Ingest outputs stable across 20+ corpus runs; ID stability verified]

  + context: Open-world ingest accumulates background knowledge.
  + IF: FUTON1 should support both interactive exploration and offline corpus ingestion
  + HOWEVER: Ingest and interactive workflows must share the same persistent state coherently
  + THEN: Stream text through deterministic CoreNLP pipeline, write entities/relations to XTDB, share state with demo/client
  + BECAUSE: Background knowledge should accumulate durably without breaking interactive exploration

  + EVIDENCE:
    evidence[apps/open-world-ingest streams text through CoreNLP to XTDB]
    evidence[Demo/client workflows hydrate from same XTDB and see ingest-produced documents]
    evidence[Open-world invariants pass end-to-end]
    evidence[README confirms deterministic ingest via CoreNLP and XTDB mirroring]

  + NEXT-STEPS:
    next[Define standard data-root layout for ingest and demo/client]
    next[Document how ingest-produced documents appear in hydrated store]
    next[Add golden tests for entity-ID stability and relation formation]
    next[Provide ingest‚Üíquery example workflow]

  :success-criteria
    pass[Ingest produces stable entity IDs across runs]
    pass[Ingest-produced documents visible in demo/client after hydration]
    pass[Questions handled correctly (not treated as assertions)]
    fail[Ingest corrupts or conflicts with interactive state]

  :psr-example "Selected open-world-ingest for corpus loading because background knowledge needs durable storage"
  :pur-template "Ingested {{doc-count}} documents, entities: {{entity-count}}, relations: {{rel-count}}"


! instantiated-by: Prototype 6 ‚Äî Demo/Client (API Demonstration) [üíñ/‰∏ö üìÅ/Á§∫]
  :maturity :active
  :depends-on [f1/P0]
  :evidence-for-settled [Demo exactly mirrors API behaviour; used as API reference in documentation]

  + context: The demo/client workflow demonstrates the API.
  + IF: Developers need to understand what the API does
  + HOWEVER: API documentation alone may not convey behaviour clearly
  + THEN: Ensure demo/client is an exact demonstration of API capabilities‚Äîsame inputs produce same outputs
  + BECAUSE: A faithful demo serves as executable documentation for the canonical interface

  + EVIDENCE:
    evidence[apps/demo and apps/client exercise the API through command-service]
    evidence[Focus headers emitted identically via CLI and API]
    evidence[README documents demo/client as API demonstration]

  + NEXT-STEPS:
    next[Verify demo/client outputs match API responses exactly]
    next[Add demo transcript that serves as API example]
    next[Document any demo-specific behaviour that differs from API]

  :success-criteria
    pass[Demo produces identical output to equivalent API calls]
    pass[Demo serves as executable API documentation]
    fail[Demo behaviour diverges from API without documentation]

  :psr-example "Selected demo/client for API learning because executable examples clarify behaviour"
  :pur-template "Demo session {{session-id}}, API-equivalent: {{yes|no}}, divergences: {{count}}"


! instantiated-by: Prototype 7 ‚Äî Query Workflows [üëì/ËßÅ ‚úåÔ∏è/ËßÅ]
  :maturity :greenfield
  :depends-on [f1/P0, f1/P3]
  :source [futon3a/P0]
  :evidence-for-active [Query functions packaged and documented; used in 10+ inspection sessions]

  + context: The stored graph must be inspectable through predictable queries.
  + IF: Developers need to examine entities, relations, salience, and schema
  + HOWEVER: Common inspection tasks currently require manual XTDB queries or scattered snippets
  + THEN: Package reusable query functions (list-entities, list-relations, inspect-entity, counts) with examples
  + BECAUSE: Consolidated query workflows reduce friction and strengthen FUTON1 as inspectable substrate

  + EVIDENCE:
    evidence[-M:storage/inspect provides automated query examples]
    evidence[README-storage.md documents XTDB inspection behaviour]
    evidence[futon3a/P0 Portal developing complementary pattern-guided retrieval]

  + NEXT-STEPS:
    next[Package query functions with brief examples in one place]
    next[Cross-reference futon3a Portal for pattern-guided queries]
    next[Surface XTDB schema in Emacs for futon3 browsing]
    next[Add query latency instrumentation]

  :success-criteria
    pass[Common queries available as named functions with examples]
    pass[Query workflows consistent between REPL and Emacs views]
    pass[futon3a Portal can use FUTON1 queries as backend]
    fail[Inspection requires ad-hoc XTDB query construction]

  :psr-example "Selected query-workflows for graph inspection because predictable queries reduce friction"
  :pur-template "Query {{query-type}}, results: {{count}}, latency: {{ms}}ms"


! instantiated-by: Prototype 8 ‚Äî Pilot Storage (fulab, MMCA) [üéë/Ê≠£ üçµ/ÂÜÖ]
  :maturity :greenfield
  :depends-on [f1/P3, f1/P1]
  :source [futon5/E1 fulab/experiment-runs]
  :evidence-for-active [fulab runs stored and retrievable; MMCA experiments stored with replay capability]

  + context: Experimental workflows need reproducible storage.
  + IF: fulab runs and MMCA experiments need durable, replayable state
  + HOWEVER: No standard way to package pilot configuration, transcripts, and expected state
  + THEN: Document pilot assembly using FUTON1 tools; implement storage for fulab (partly done) and MMCA experiments (planned)
  + BECAUSE: Experimental futons (futon2, futon5) require stable backend for storing and replaying world state

  + EVIDENCE:
    evidence[fulab runs partly implemented with FUTON1 storage]
    evidence[MMCA experiment storage planned for futon5 E1]
    evidence[FUTON1 supports deterministic transcripts and XTDB-backed persistence]
    evidence[CLI and API can drive scripted workflows]

  + NEXT-STEPS:
    next[Complete fulab run storage integration]
    next[Design MMCA experiment storage schema]
    next[Document pilot assembly guide with worked example]
    next[Provide minimal pilot example with config, transcripts, expected state]

  :success-criteria
    pass[fulab runs stored and retrievable via FUTON1]
    pass[MMCA experiments can be stored and replayed]
    pass[Pilot state verifiable through query workflows]
    fail[Experiment state lost or non-reproducible]

  :psr-example "Selected pilot-storage for fulab integration because experiments need durable replay"
  :pur-template "Stored pilot {{pilot-id}}, type: {{fulab|mmca}}, artifacts: {{count}}"
