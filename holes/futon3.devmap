@multiarg futon3/devmap
@title FUTON3 Development Map ‚Äî Flexiformal Proofwork & Pattern Checking
@audience futon-devs, sandbox-agents, future-you
@tone formal-analytic
@style roadmap
@factor Joy / Rapture (pƒ´ti)
@IFR: FUTON3 turns messy activity into organised knowledge by checking work
against shared patterns and producing auditable records that other futons can
use to learn, improve, and act.
@state MUSN transport runs reliably, pattern canon operational in futon1 storage,
check DSL exercised end-to-end, trails capture tatami sessions, workday
instrumentation bridges aob-chatgpt. Gaps: similarity field not wired into APIs;
intent embedding designed but not implemented; joy metrics not yet flowing to
futon0; proof hooks still bespoke scripts.
@next Wire similarity field into pattern search API; implement intent embedding
pipeline; standardise proof‚Üígraph and proof‚Üíenergy exports; land joy metrics
as futon0 service.

## The Argument

FUTON3 turns messy activity into organised knowledge by checking work against
shared patterns and producing auditable records. The MUSN transport provides
stable IO contracts for pattern-related checking with deterministic transcripts.
The pattern canon stores patterns with metadata and devmap links in futon1
storage. The check DSL evaluates pattern applicability and logs every check as
a proof-state record. Trails capture proof obligations and how sessions
discharged them. Workday instrumentation bridges aob-chatgpt and fubar.el so
user interactions flow into the check pipeline. The similarity field enables
pattern suggestions via sigil-distance and GloVe embeddings. Intent embedding
types each proof step as (fruit, orb) pairs for Kolmogorov-style constructive
proofs. The pattern workbench drafts candidate flexiargs from accumulated proof
states. Joy metrics track empowerment‚Äîtime-to-proof, obligations cleared,
commitments enabled‚Äîand are provided to futon0. Proof hooks export checks to
futon1 (graph) and futon2 (viriya). The training ground packages tutorials so
humans and agents can practice flexiformal checks. System self-description makes
stack components queryable entities in the hypergraph.


! instantiated-by: Prototype 0 ‚Äî MUSN Transport Baseline [‚û∞/Âèå üéë/‰∫Ü]
  :maturity :active
  :depends-on []
  :evidence-for-active [Transport running 90+ days; event logging operational; pattern checks flow through router]

  + context: FUTON3 rides the MUSN transport (WS+HTTP bus, SAFE/ADMIN REPL, NDJSON ingest) for pattern-related checking.
  + IF: You want an execution substrate where pattern obligations can be posed, evaluated, and recorded with deterministic transcripts
  + HOWEVER: Without frozen contracts, check jobs cannot rely on stable log formats
  + THEN: Freeze the transport contract for pattern-apply, gap-report, and trail-capture; provide golden transcripts; version the sandbox profile as the canonical proofwork runtime
  + BECAUSE: Flexiformal checking needs a stable log format before any higher-layer reasoning can rely on it

  + EVIDENCE:
    evidence[docs/protocol.md documents transport contracts]
    evidence[src/f2/router.clj implements event routing]
    evidence[test/f2/router_test.clj has 100-event idempotency + acceptance tests]
    evidence[test/transport_test.clj covers per-client disconnect logging]

  + NEXT-STEPS:
    next[Freeze transport contract v1 in docs/protocol/transport-contract-v1.md]
    next[Add golden transcripts for pattern-apply, gap-report, trail-capture]
    next[Document sandbox profile as canonical proofwork runtime]

  :success-criteria
    pass[Transport contract frozen and versioned]
    pass[Golden transcripts reproducible from sandbox profile]
    pass[Check jobs have stable log formats]
    fail[Contract changes break downstream consumers]

  :psr-example "Selected MUSN transport for check jobs because stable IO contracts enable reproducible proofwork"
  :pur-template "Transport event {{type}}, client: {{client}}, logged: {{yes|no}}"


! instantiated-by: Prototype 1 ‚Äî Pattern Canon & Standard Library [üê∫/Êú¨ ‚û∞/‰∏ñ]
  :maturity :active
  :depends-on [f1/P0]
  :evidence-for-active [Pattern store operational in futon1; ingest working; tests pass]

  + context: A flexiarg/pattern library exists but was scattered across files.
  + IF: You want FUTON3 to curate patterns with metadata, linking obligations, and proof status
  + HOWEVER: Without a canonical store, the checker has nothing trustworthy to compare against
  + THEN: Stand up f3.patterns store (ID, clauses, references, pƒÅramitƒÅ tags, fruits/orbs weights) in futon1 storage; keep in sync with filesystem devmaps as "checked out working copy"
  + BECAUSE: Pattern-based inference requires stable, addressable patterns that can be inspected and edited across the stack

  + EVIDENCE:
    evidence[Pattern store working in futon1 with ingest]
    evidence[resources/pattern_store.edn maintains catalog]
    evidence[src/futon3/pattern_store.clj implements store API]
    evidence[test/pattern_store_test.clj verifies sync with README references]

  + NEXT-STEPS:
    next[Add golden test proving store loads and enumerates all pattern IDs]
    next[Add golden test asserting metadata completeness (ID, clauses, refs, tags, weights)]
    next[Verify pattern store matches standard library with no omissions]

  :success-criteria
    pass[Pattern store loads at runtime with stable set of IDs]
    pass[Each pattern has required metadata and valid source links]
    pass[Store matches filesystem library exactly]
    fail[Patterns only exist on disk, not accessible to stack]

  :psr-example "Selected pattern canon for check DSL because addressable patterns enable programmatic checking"
  :pur-template "Pattern {{id}} loaded, clauses: {{count}}, tags: {{tags}}"


! instantiated-by: Prototype 2 ‚Äî Check DSL & Applicability Engine [üåΩ/Êú´ ‚û∞/Âπø]
  :maturity :active
  :depends-on [f3/P0, f3/P1]
  :evidence-for-active [check! API operational; schema validation working; checks logged]

  + context: FUTON3 answers "can this pattern apply?" and "what obligations arise?"
  + IF: You want a declarative DSL for posing check contexts and receiving structured verdicts
  + HOWEVER: Without executable checks, patterns remain narrative rather than flexiformal
  + THEN: Define check! API (inputs: pattern ID, context EDN, evidence refs; outputs: status, missing fields, derived tasks); enforce schema validation; log every check as proof-state record
  + BECAUSE: Turning patterns into executable checks is what makes FUTON3 flexiformal

  + EVIDENCE:
    evidence[src/futon3/checks.clj implements check DSL]
    evidence[src/f2/router.clj routes check requests]
    evidence[src/futon3/futon1_bridge.clj wires to futon1]
    evidence[test/transport_test.clj covers workday/check forwarding]

  + NEXT-STEPS:
    next[Ship futon1/futon2 adapters so checks replicate to graph + viriya stores]
    next[Expose /musn/check over HTTP once transport contract frozen]
    next[Add check latency instrumentation]

  :success-criteria
    pass[check! returns structured verdicts (applies/blocked/missing)]
    pass[Every check logged as proof-state record]
    pass[Schema validation enforced on inputs]
    fail[Checks proceed without logging]

  :psr-example "Selected check DSL for pattern evaluation because executable checks enable automation"
  :pur-template "Check {{pattern}}, context: {{ctx}}, result: {{status}}"


! instantiated-by: Prototype 3 ‚Äî Trail & Proof-State Journal [‚û∞/Âèå]
  :maturity :active
  :depends-on [f3/P2]
  :evidence-for-active [Tatami sessions captured; trail schema operational; cue embedding tested]

  + context: Wisdom trails document proof obligations and how work sessions discharged them.
  + IF: You want every check, dismissal, and pattern idea to leave an auditable trail
  + HOWEVER: Without proof-state schema, trails are general exploration logs
  + THEN: Extend trail schema with :pattern/id, :obligation/id, :action/tags, :delta/joy; add rollups showing which devmap clauses advanced per day; expose /musn/trails/proof export
  + BECAUSE: The whole point is to measure how daily practice advances the devmaps

  + EVIDENCE:
    evidence[resources/tatami-events.edn captures live tatami sessions]
    evidence[resources/tatami-context.edn logs FROM-CHATGPT-EDN payloads]
    evidence[test/futon3/cue_embedding_test.clj proves keyword payloads round-trip]
    evidence[Tatami HUD mirrors entries through /musn/cues]

  + NEXT-STEPS:
    next[Persist cue annotations into trail export]
    next[Add proof artifacts (HUD screenshots or /musn/cues transcripts)]
    next[Implement daily rollups of clause advancement]

  :success-criteria
    pass[Trails include pattern/obligation IDs]
    pass[Rollups show devmap clause progress per day]
    pass[Proof export available for futon4 archives]
    fail[Proof states not captured in trails]

  :psr-example "Selected trails for proof journaling because auditable records enable reflection"
  :pur-template "Trail {{session}}, patterns: {{count}}, obligations cleared: {{cleared}}"


! instantiated-by: Prototype 4 ‚Äî Workday Instrumentation [‚û∞/Ê≠¢ ‚åõÔ∏è/‰∫Ü]
  :maturity :active
  :depends-on [f3/P2]
  :evidence-for-active [workday/submit endpoint operational; aob-chatgpt bridge working]

  + context: aob-chatgpt and fubar.el instrument user interactions for pattern checking.
  + IF: You want FUTON3 to serve as backend for daily reflections
  + HOWEVER: Without official API, workday claims cannot flow through check pipeline
  + THEN: Publish workday/submit endpoint (timestamp, activity, evidence links); run through check DSL + embedding; respond with pattern hits/misses and follow-up obligations
  + BECAUSE: This is how empowered action becomes measurable proof progress

  + EVIDENCE:
    evidence[src/futon3/workday.clj implements workday intake]
    evidence[test/transport_test.clj covers workday submission]
    evidence[README documents workday API]

  + NEXT-STEPS:
    next[Replace futon3/logs/workday.edn queue with futon1 persistence (workday->graph)]
    next[Add HTTP affordances for instrumentation stewards]
    next[Integrate fubar.el alongside aob-chatgpt]

  :success-criteria
    pass[Workday claims flow through check DSL]
    pass[Pattern hits/misses returned with follow-up obligations]
    pass[Both aob-chatgpt and fubar.el can submit]
    fail[Workday claims bypass pattern checking]

  :psr-example "Selected workday instrumentation for aob-chatgpt because daily practice needs pattern feedback"
  :pur-template "Workday submit {{timestamp}}, patterns matched: {{count}}, obligations: {{new}}"


! instantiated-by: Prototype 5 ‚Äî Similarity Field [üåÇ/Áî≤ üëÇ/ÂΩí]
  :maturity :greenfield
  :depends-on [f3/P1]
  :evidence-for-active [Similarity queries integrated; deterministic neighbourhoods tested]

  + context: Sigil-distance and GloVe embeddings enable pattern suggestions.
  + IF: You want reproducible neighbourhood queries for pattern suggestions
  + HOWEVER: Embeddings live in ad-hoc CSVs, not wired into FUTON3 APIs
  + THEN: Integrate sigil-distance matrix and GloVe embeddings as first-class service (pattern search API, nearest-patterns command, CLI/UI views); publish tests proving deterministic neighbourhoods
  + BECAUSE: Pattern suggestion quality underpins the flexiformal workflow

  + EVIDENCE:
    evidence[Sigil-distance matrix exists in CSVs]
    evidence[GloVe embeddings available]

  + NEXT-STEPS:
    next[Wire embeddings into pattern search API]
    next[Add nearest-patterns command]
    next[Publish deterministic neighbourhood tests]
    next[Add CLI/UI views for pattern suggestions]

  :success-criteria
    pass[Pattern search API returns nearest patterns]
    pass[Neighbourhoods deterministic across runs]
    pass[Both sigil-distance and GloVe queryable]
    fail[Pattern suggestions require manual lookup]

  :psr-example "Selected similarity field for pattern discovery because neighbourhood queries enable exploration"
  :pur-template "Similarity query {{pattern}}, neighbours: {{count}}, method: {{sigil|glove}}"


! instantiated-by: Prototype 6 ‚Äî Intent Embedding & Proof Typing [‚û∞/Âèå üçç/Âäû]
  :maturity :greenfield
  :depends-on [f3/P3]
  :evidence-for-active [Intent‚Üívec pipeline operational; fruit/orb types assigned to proof steps]

  + context: Trails record patterns but don't type proof steps as constructive operations.
  + IF: You want to distinguish "this is a check" from "this is an indicator preserving a virtue invariant"
  + HOWEVER: Current schema has no machinery to interpret intent‚Üípattern reasoning as typed proof steps
  + THEN: Define intent‚Üívec pipeline mapping :trail/intent + :pattern/reasoning to (fruit, orb) pairs where fruits encode operator classes and orbs encode meta-properties; compute :rule/salience; write back to trail events
  + BECAUSE: In Kolmogorov's sense, a proof is a construction; typing steps like "indicator‚Üívirtue-aligned" lets you see what kind of proof work actually happened

  + EVIDENCE:
    evidence[Cue embedding tests show keyword payloads round-trip]
    evidence[resources/paramita-grid.edn provides gold set for fruit/orb recovery]

  + NEXT-STEPS:
    next[Generalise cue embedding to operate on intent + reasoning tuples]
    next[Calibrate fruit/orb basis on manually typed patterns]
    next[Wire enriched trail export into rollups]
    next[Add HUD affordances to filter by proof type]

  :success-criteria
    pass[Each trail step typed as (fruit, orb) pair]
    pass[Salience scores computed for proof steps]
    pass[Rollups show proof types that fired per day]
    fail[Proof steps remain untyped]

  :psr-example "Selected intent embedding for proof typing because Kolmogorov-style types enable meta-reasoning"
  :pur-template "Intent embed {{step}}, fruit: {{fruit}}, orb: {{orb}}, salience: {{score}}"


! instantiated-by: Prototype 7 ‚Äî Pattern Creation Workbench [üëç/Â∑≤]
  :maturity :greenfield
  :depends-on [f3/P3, f3/P6]
  :evidence-for-active [Summariser clusters trails; draft flexiargs emitted with readiness criteria]

  + context: New patterns emerge from trails and devmap edits but capture is manual.
  + IF: You want FUTON3 to draft candidate patterns from accumulated proof states
  + HOWEVER: Manual backlog creates tension; no readiness criteria for handoff
  + THEN: Build summariser that clusters trails, extracts hooks, emits draft flexiarg blocks (IF/HOWEVER/THEN/BECAUSE) with suggested pƒÅramitƒÅ; declare readiness criteria (N supporting checks + steward review)
  + BECAUSE: FUTON3 should propose expansions grounded in lived work

  + EVIDENCE:
    evidence[Trail data available for clustering]
    evidence[Flexiarg format documented]

  + NEXT-STEPS:
    next[Build trail clustering summariser]
    next[Emit draft flexiarg blocks with pƒÅramitƒÅ tags]
    next[Define readiness criteria for handoff to futon4]
    next[Add steward review workflow]

  :success-criteria
    pass[Summariser emits draft flexiargs from trails]
    pass[Drafts tagged with suggested pƒÅramitƒÅ]
    pass[Readiness criteria declared and enforced]
    fail[Pattern creation remains fully manual]

  :psr-example "Selected pattern workbench for library growth because automated drafts reduce manual burden"
  :pur-template "Workbench draft {{id}}, sources: {{trail_count}}, readiness: {{status}}"


! instantiated-by: Prototype 8 ‚Äî Joy Metrics [‚åõÔ∏è/Âäõ ‚ö°Ô∏è/‰∫å]
  :maturity :greenfield
  :depends-on [f3/P3, f3/P4]
  :evidence-for-active [Joy metrics computed per session; provided to futon0]

  + context: Joy = Spinozan increase in power to act, evidenced by commitments you can now keep.
  + IF: You want metrics showing whether checks are empowering or draining
  + HOWEVER: Current metrics counted UI friction, not proofs discharged
  + THEN: Track time-to-proof, obligations-cleared, follow-on commitments, viriya linkages per session; visualise alongside subjective notes; provide to futon0
  + BECAUSE: Empowered action is the KPI for this futon

  + EVIDENCE:
    evidence[Session data available from trails]
    evidence[Obligation tracking in check DSL]

  + NEXT-STEPS:
    next[Define joy metric formulas]
    next[Implement per-session computation]
    next[Wire metrics to futon0]
    next[Add visualization alongside subjective notes]

  :success-criteria
    pass[Joy metrics computed per session]
    pass[Metrics provided to futon0]
    pass[Visualizations show empowerment trends]
    fail[Joy unmeasured or disconnected from futon0]

  :psr-example "Selected joy metrics for empowerment tracking because pƒ´ti factor requires measurable progress"
  :pur-template "Joy session {{id}}, time-to-proof: {{ms}}, cleared: {{count}}, commitments: {{new}}"


! instantiated-by: Prototype 9 ‚Äî Proof Hooks (futon1/futon2 Export) [‚ö°Ô∏è/‰∫å üôÖ/‰πÉ]
  :maturity :greenfield
  :depends-on [f3/P2, f1/P0, f2/P6]
  :evidence-for-active [proof‚Üígraph materialises relations; proof‚Üíenergy emits viriya deltas]

  + context: FUTON3 generates proof states; futon1 (graph) and futon2 (viriya) need them as fuel.
  + IF: You want every accepted check to become a graph relation and viriya delta automatically
  + HOWEVER: Current exports are bespoke scripts
  + THEN: Standardise proof‚Üígraph (materialise relations with provenance) and proof‚Üíenergy (emit activation deltas); lock with fixtures + schemas
  + BECAUSE: Proofs only matter when other futons can act on them

  + EVIDENCE:
    evidence[Tatami events available for export]
    evidence[futon1 graph-memory API operational]
    evidence[futon2 pivot streams accept deltas]

  + NEXT-STEPS:
    next[Wire tatami event log into futon1 via tatami_store.clj]
    next[Standardise proof‚Üígraph adapter with fixtures]
    next[Standardise proof‚Üíenergy adapter with fixtures]
    next[Document export schemas]

  :success-criteria
    pass[Accepted checks become graph relations automatically]
    pass[Viriya deltas emitted for futon2 dashboards]
    pass[Adapters locked with fixtures and schemas]
    fail[Export requires manual scripting]

  :psr-example "Selected proof hooks for cross-futon integration because automated export enables composition"
  :pur-template "Proof export {{check}}, graph relations: {{rels}}, viriya delta: {{delta}}"


! instantiated-by: Prototype 10 ‚Äî Flexiformal Training Ground [üö¢/Ê∞è üö¥/Êú™]
  :maturity :greenfield
  :depends-on [f3/P2, f3/P3]
  :evidence-for-active [Training ground packaged; tutorials complete; simulator recorded]

  + context: FUTON3 needs a reproducible training ground for flexiformal practice.
  + IF: You want collaborators (including FUTON6 math stewards) to experience the proof workflow
  + HOWEVER: No packaged simulator/tutorial bundle exists
  + THEN: Package "Flexiformal Training Ground" release: tutorials referencing t4r/ patterns, sample check sessions, minimal simulator feeding FUTON6's Hyperreal entries; name facilitators and consumers; publish readiness criteria
  + BECAUSE: Training ground turns FUTON3 into a reproducible service for upstream layers

  + EVIDENCE:
    evidence[Check DSL operational for training]
    evidence[Trail capture available for transcripts]

  + NEXT-STEPS:
    next[Write tutorials referencing t4r/ patterns]
    next[Record sample check sessions]
    next[Build minimal simulator for FUTON6]
    next[Aggregate proof events into proof-chain.edn]

  :success-criteria
    pass[Training ground packaged with tutorials]
    pass[Sample sessions reproducible]
    pass[Simulator feeds FUTON6 entries]
    fail[Training requires undocumented setup]

  :psr-example "Selected training ground for onboarding because reproducible practice enables collaboration"
  :pur-template "Training session {{id}}, checks: {{count}}, transcript: {{path}}"


! instantiated-by: Prototype 11 ‚Äî System Self-Description [üîÉ/Êú¨]
  :maturity :greenfield
  :depends-on [f3/P1, f1/P0]
  :evidence-for-active [Manifest schema defined; stack components queryable in futon1]

  + context: Documentation and APIs exist as separate artifacts that humans must correlate.
  + IF: You want agents to query the system about its own capabilities
  + HOWEVER: No machine-readable manifest makes components first-class entities
  + THEN: Unify documentation and APIs into machine-readable manifest; make stack components first-class entities in futon1; enable agents to query capabilities and self-verify structure
  + BECAUSE: This closes the reflexivity loop‚Äîa semantic network that includes a model of itself

  + EVIDENCE:
    evidence[futon4/docs/evidence/rc-1.1-evidence.edn seeds machine-readable claim map]

  + NEXT-STEPS:
    next[Expand evidence map into manifest schema (components, interfaces, invariants)]
    next[Ingest manifest into futon1]
    next[Enable agents to query stack capabilities]
    next[Add self-verification of running system vs declared structure]

  :success-criteria
    pass[Manifest schema covers all stack components]
    pass[Components queryable as futon1 entities]
    pass[Running system verifiable against manifest]
    fail[Self-description requires manual correlation]

  :psr-example "Selected self-description for reflexivity because queryable structure enables agent reasoning"
  :pur-template "Manifest query {{component}}, interfaces: {{count}}, verified: {{yes|no}}"
