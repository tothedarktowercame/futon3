@flexiarg agency/loud-failure
@title Errors Surface at the Layer That Caused Them
@sigils [ðŸ“¢/å£°]
@keywords error, failure, exception, silent, propagation, diagnostic
@audience agency maintainers, futon developers
@tone analytic-foundational
@style pattern
@references [futon-theory/error-hierarchy storage/error-layer-hierarchy]

! conclusion: Every error in Agency must surface at the layer that caused it with enough context to diagnose; silent catch-and-swallow is never acceptable.
  + context: Agency code contains 20+ instances of (catch Exception _ nil) or (catch Exception e (log! ...) false) across service.clj, invokes.clj, and http.clj. Corrupted state files load as defaults without warning. Subprocess parsing errors are skipped. Forum and MUSN post failures are swallowed. The log function itself swallows its own errors.
  + IF:
    An operation fails â€” network error, parse error, subprocess crash, file corruption, timeout.
  + HOWEVER:
    The current pattern catches exceptions at every boundary and converts them to nil, false, or logged-but-forgotten entries. Callers cannot distinguish "succeeded with empty result" from "failed silently." Operators cannot diagnose issues because the error was absorbed three layers below.
  + THEN:
    Apply the error hierarchy from futon-theory/error-hierarchy to Agency:
    1. Layer 0 (transport/durability): HTTP, WS, and file I/O errors surface as transport failures with status codes.
    2. Layer 1 (identity): Agent not found, session-id mismatch surface as resolution failures.
    3. Layer 2 (integrity): State corruption, partial rollover surface as integrity failures.
    4. Layer 3 (invocation): Subprocess timeout, parse error, empty result surface as invocation failures.
    5. Layer 4 (validation): Missing fields, bad request surface as validation failures.
    Every catch block must either:
    a. Propagate the error with context (layer, agent-id, operation, cause), OR
    b. Handle it with an explicit recovery action that is itself logged.
    Catch-and-ignore is removed from the codebase entirely.
  + BECAUSE:
    Silent errors make debugging impossible. When a standup fails and no agent responds, the operator has no trail: was the bell not sent? Was it sent but not received? Was it received but the agent crashed? Was the response generated but MUSN was down? Without layer-attributed errors, every failure investigation starts from zero.

  + INVARIANT-STATEMENT:
    A3-hierarchy: No exception handler in Agency may discard an error without either (a) returning an error result to the caller with layer, agent-id, and cause, or (b) executing an explicit recovery action that is logged with the original error context.

  + ENFORCEMENT:
    - grep for (catch Exception _) and (catch Throwable _) â€” zero allowed
    - grep for {:throw-exceptions false} â€” each must be followed by status check
    - grep for (log! ... false) â€” log-and-return-false is not error handling

  + ANTI-PATTERNS:
    - (catch Exception _ nil) â€” the canonical silent swallow
    - (catch Exception e (log! "error" {:err (.getMessage e)}) false) â€” logged but not propagated
    - {:throw-exceptions false} without (when-not (= 200 (:status resp)) ...) â€” HTTP error suppression

  + NEXT-STEPS:
    - evidence: count all silent catch blocks in agency/ directory; target is zero
    - evidence: classify each catch block by layer (transport, identity, integrity, invocation, validation)
    - evidence: measure time-to-diagnosis for a sample failure before and after fix
    - evidence-shape: {:error/layer :keyword, :error/operation :string, :error/agent-id :string, :error/cause :string, :error/recovery :keyword, :error/propagated? :boolean, :error/ts :string}
