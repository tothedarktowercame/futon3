@multiarg futon1/devmap
@title FUTON1 Development Map
@audience futon-devs, infra-agents, future-you
@tone formal-analytic
@style roadmap
@allow-new-claims true
@length any
@factor Keen investigation (dhammavicaya)
@IFR:
FUTON1 provides a deterministic, storage-oriented substrate that maintains a
coherent graph of facts across sessions. It keeps Datascript (fast) and XTDB
(persistent) in reproducible alignment so that the same world state appears
reliably across restarts and environments. It exposes a minimal CLI and HTTP
surface for ingesting text, inspecting entities and relations, and emitting
stable summaries‚Äîsuch as focus headers‚Äîthat downstream code can depend on
without embedding persistence or orchestration logic.

FUTON1 supports keen investigation by making the fact graph inspectable and
faithful to stored state. Its role is limited to storage, hydration, and
deterministic summarisation: it does not prescribe inference or policy. When
this layer operates cleanly, other futons inherit a durable and predictable
world model on which more complex behaviours can be built.

@state
The deterministic demo/client workflow and Datascript‚ÜîXTDB mirroring are
operational, with sessions hydrating from XT on boot and falling back to the
legacy log + snapshot when XTDB is disabled. Futon1 remains storage- and
durability-focused: `apps/demo` is the interactive entry point and the HTTP
API module (`clojure -M:api` / `apps/api`) is the external client surface.

Operational caveats: multiple Futon processes against the same
`BASIC_CHAT_DATA_DIR` can trigger RocksDB lock errors, and open-world ingest
treats questions as assertions (there is no question‚ÜíDatalog mapping yet).
@next
Consolidate the documentation and contracts that define how text becomes graph state; stabilise the naming and configuration surfaces shared across CLI, API, and ingest workflows; and refine test coverage so the deterministic substrate remains reliable as modules evolve. Maintain FUTON1‚Äôs minimal scope‚Äîstorage, hydration, and inspection‚Äîwhile ensuring that higher futons can depend on its interfaces without ambiguity.

! instantiated-by: Prototype 0 ‚Äî Baseline Deterministic Substrate [üåù/Âõõ üêú/Âü∫]

+ context:
  FUTON1 provides a deterministic storage substrate built from the demo/client
  workflow, the NLP interface, graph-memory, and XTDB persistence. These
  components together define the minimal end-to-end path by which text becomes
  durable graph state and can be inspected through the CLI or HTTP API.

+ if:
  You want a stable understanding of what FUTON1 currently guarantees‚Äîits
  ingest pipeline, hydration behaviour, and contract surfaces‚Äîbefore extending
  or modifying any part of the stack.

+ however:
  Documentation and examples are distributed across several READMEs; the
  overall ‚Äústack story‚Äù from ingest to XTDB is implicit rather than expressed
  as a single reference artifact, and the exact boundaries of the deterministic
  substrate are easy to lose track of during development.

+ then:
  Capture a baseline snapshot of the current system: record a concise
  architecture note describing the pipeline (ingest ‚Üí NLP ‚Üí graph-memory ‚Üí
  XTDB), freeze representative transcripts from the demo/client workflow, and
  tag a reference point that reflects the present deterministic behaviour.

+ because:
  A clear baseline makes the substrate‚Äôs guarantees explicit, helps detect
  regressions in hydration or pipeline flow, and provides a stable reference
  against which future refinements or extensions can be evaluated.

+ evidence:
  - README documents deterministic demo/client behaviour, NLP interface,
    graph-memory schema, and XTDB hydration.
  - `apps/demo`, `apps/client`, `apps/nlp-interface`, `apps/graph-memory`, and
    `apps/open-world-ingest` form the operational substrate.
  - XTDB inspection and hydration behaviour are reproducible through existing
    scripts and aliases.
  - `/api/alpha/meta/model/registry` exposes live model descriptors for
    patterns, docbook, open-world ingest, and the meta-model, with
    `/api/alpha/meta/model/queue` reporting pending coverage.
  - Open-world invariants pass end-to-end, including stub detection and
    relation type registration.

+ next:
  Compile the architecture note; select and store a minimal set of canonical
  transcripts; and publish them alongside a tagged release that marks the
  baseline behaviour.
  - Add a lightweight `/api/alpha/entities/latest?type=...` endpoint (or
    equivalent) so downstream tools can fetch only the most recent
    `:clock-out/summary` (or other entity type) instead of paging the entire
    history when verifying persistence.

+ next-evidence:
  - A dated, versioned snapshot containing architecture notes and
    representative transcripts.
  - CI or local reproducibility checks demonstrating identical XTDB and
    focus-header outputs under the baseline tag.
  - A single README-level reference pointing to the baseline for future
    comparison.


! instantiated-by: Prototype 1 ‚Äî Demo/Client Determinism & Focus-Header Instrumentation [üí§/ÊØè üë¥/Âæã]

+ context:
  The `apps/demo` and `apps/client` workflow is the canonical entry point for
  interrogating the stack. It emits deterministic focus headers, hydrates from
  XTDB on startup, and exercises the NLP interface and graph-memory module
  together, exposing how ingest, mutation, and inspection behave in practice.

+ if:
  You want the CLI and client workflow to act as reliable instrumentation for
  investigating hydration, salience updates, and focus-header formation‚Äî
  producing traces that can be compared across runs and environments.

+ however:
  Existing smoke tests cover only narrow paths, and the behaviour of hydration,
  persistence, and focus-header emission under varied configurations is not yet
  exercised systematically. Legacy assumptions from earlier protocols still
  colour expectations about determinism.

+ then:
  Establish a minimal determinism suite for the demo/client workflow: select a
  small set of representative sessions, fix their configuration, and record the
  expected XTDB and focus-header outputs. Treat these as canonical fixtures
  checked under CI so that changes in hydration, pipeline flow, or header
  structure become immediately visible.

+ because:
  Treating the demo/client workflow as calibrated instrumentation‚Äîrather than
  an informal demo‚Äîprovides a stable, reproducible surface for higher futons,
  lets developers detect drift in persistence or header logic, and clarifies
  exactly what guarantees FUTON1 provides.

+ evidence:
  - README documents deterministic demo/client behaviour, focus-header output,
    and XTDB hydration.
  - Golden fixtures already exist for graph-memory and NLP layers.
  - XT inspection paths (`-M:storage/inspect`) demonstrate reproducible
    hydration and salience persistence.
  - CI green on commit 7611ea2 for `Futon1 Deterministic Stack` (apps/client,
    apps/graph-memory, apps/nlp-interface).

+ next:
  Curate a minimal determinism suite; freeze representative focus-header and
  XTDB outputs; and integrate these checks into CI as regression indicators.

+ next-evidence:
  - A small directory of canonical demo/client transcripts with corresponding
    expected XTDB states.
  - CI reports confirming stability of determinism across tagged commits.
  - Clear README references linking these fixtures to FUTON1‚Äôs guarantees.

! instantiated-by: Prototype 2 ‚Äî NLP Interface Consolidation [üë¥/Áî≥ üåΩ/ÂÜÖ]

+ context:
  `apps/nlp-interface` provides deterministic NER/POS tagging and a small set of
  pattern-recognition hooks used across ingest and demo/client workflows. It is
  the shared entry point for turning raw text into structured tokens that the
  rest of FUTON1 can rely on without ambiguity.

+ if:
  You want a single, well-defined NLP module whose behaviour is testable,
  documented, and independent of the surrounding CLI or transport logic.

+ however:
  The current README gives only a minimal overview of the pipeline, and the
  boundaries between tokenisation, tagging, chunking, and downstream pattern
  recognition remain implicit in code rather than expressed as a clear API.
  Tests cover specific fixtures but not the full staged behaviour.

+ then:
  Make the pipeline stages explicit: document and expose the tokenise ‚Üí tag ‚Üí
  chunk ‚Üí recognise flow, write unit tests for each stage, and provide a brief,
  focused README describing the module‚Äôs public API, expected inputs and
  outputs, and how upstream components should depend on it.

+ because:
  A consolidated and documented NLP interface provides a stable grounding for
  ingest and demo/client workflows, reduces accidental coupling, and makes it
  easier to extend or revise individual stages without destabilising the rest
  of FUTON1.

+ evidence:
  - README describes deterministic NER/POS behaviour and shared pipeline usage.
  - Test runners exist for NLP fixtures (`apps/nlp-interface/test`).
  - Pattern-recognition hooks are already used in ingest and CLI flows.

+ next:
  Clarify the staged pipeline, expand tests to cover each stage, and produce a
  concise README that reflects the actual API and expected data shapes.

+ next-evidence:
  - Stage-by-stage unit tests passing under CI.
  - Updated README documenting pipeline flow and public functions.
  - Agreement across ingest and demo/client modules on API usage.

! instantiated-by: Prototype 3 ‚Äî Graph-Memory API & Seed Graph [üí§/Áªú üôÖ/‰πÉ]

+ context:
  `apps/graph-memory` defines the Datascript schema, salience metadata, and
  store management functions that underpin FUTON1‚Äôs fact graph. It coordinates
  in-memory state with XTDB persistence and is the central place where entity
  and relation documents are shaped before being written or read.

+ if:
  You want FUTON1 to expose a clear, documented contract for how entities,
  relations, and salience fields are represented and mirrored between
  Datascript and XTDB, so that other futons and external tools can rely on the
  same facts without depending on internal implementation details.

+ however:
  The existing README and tests describe schema and storage behaviour but do
  not yet present a concise API-level view of graph operations. Helper
  functions are still oriented toward REPL use, naming conventions vary, and
  there is no single description of what is considered part of the persistent
  ‚Äúseed graph‚Äù or which documents are guaranteed to be mirrored into XTDB.

+ then:
  Promote `graph-memory` to a documented API: define the core entity and
  relation operations (init, upsert, link, query), state explicitly which
  fields and document types are mirrored into XTDB, and describe any default
  seed graph that is expected to exist in a fresh store. Align naming and
  function boundaries with this contract and treat incompatible changes as
  migrations rather than ad-hoc edits.

+ because:
  A clear graph-memory contract turns FUTON1‚Äôs internal schema and store logic
  into a reliable interface. This allows higher futons and external tools to
  depend on the same graph representation, reduces ambiguity about what is
  persisted, and makes changes to the underlying storage behaviour visible and
  deliberate.

+ evidence:
  - README documents the Datascript schema, XTDB touchpoints, and hydration
    behaviour used by FUTON1.
  - Test suites for graph-memory exercise persistence and salience fields.
  - XT inspection paths demonstrate how entity and relation documents are
    stored and reloaded.

+ next:
  Extract and name the core graph-memory operations as a public API, document
  which document types and fields are mirrored into XTDB, and describe any
  expected seed graph in the module README.

+ next-evidence:
  - An updated `apps/graph-memory` README that presents the API, mirroring
    rules, and seed-graph expectations in one place.
  - Tests that target the documented API functions rather than only internal
    helpers.
  - A short migration note for any changes that affect stored documents or
    XTDB layout.


! instantiated-by: Prototype 4 ‚Äî XTDB Operations & REPL Workflows [üêú/ÂàÜ üë≠/‰ªä]

+ context:
  FUTON1 mirrors all graph mutations into XTDB and provides a stable hydration
  path so that entity and relation documents, salience fields, and type data
  persist across restarts. The repository already includes REPL notes,
  inspection snippets, and a dedicated `-M:storage/inspect` entry point for
  examining the store directly.

+ if:
  You want developers to inspect, query, and verify the persistent store using
  a small set of predictable entry points, without relying on ad-hoc XTDB
  queries or bespoke REPL sessions.

+ however:
  Common inspection tasks‚Äîlisting entities, examining relations, checking
  salience fields, or understanding schema layout‚Äîstill require manual XTDB
  queries or scanning several snippets across READMEs and test files. These
  workflows are reliable but not yet consolidated into a minimal operational
  interface.

+ then:
  Package the existing XTDB inspection workflows into a small set of reusable
  functions (e.g., list-entities, list-relations, inspect-entity, counts),
  present them in one place with brief examples, and highlight the
  salience-survives-restart demonstration as a canonical illustration of the
  hydration contract. Treat these recipes as the reference interface for
  inspecting and understanding FUTON1‚Äôs persistent state.

+ because:
  Consolidating XTDB operations into clear, reusable workflows reduces
  friction, makes store inspection more consistent, and strengthens FUTON1‚Äôs
  role as a deterministic storage substrate rather than an opaque backend.
  Developers gain a predictable way to understand how mutations appear in XTDB
  and how hydration restores them.

+ evidence:
  - `README-storage.md` documents XTDB inspection behaviour and usage.
  - The `-M:storage/inspect` alias provides automated examples of querying the
    store.
  - Hydration and salience persistence are demonstrated through existing
    scripts and XT touchpoints.

+ next:
  Surface the same XTDB schema and inspection workflows in Emacs so FUTON3 can
  browse persistent store contents without relying on filesystem paths or
  ad-hoc REPL interaction.

+ next-evidence:
  - A simple Emacs view that displays XT entities, relations, and salience
    metadata using the documented inspection functions.
  - Consistent behaviour between the Emacs view and the REPL inspection entry
    points.

! instantiated-by: Prototype 5 ‚Äî Open-World Ingest Workflows [üî¶/ÂºÄ üë≠/‰π¶]

+ context:
  `apps/open-world-ingest` streams arbitrary text through a deterministic
  CoreNLP pipeline and writes entities, mentions, and relations into XTDB.
  These documents become part of the same persistent store that the
  demo/client workflow hydrates on startup, allowing background knowledge to
  accumulate outside interactive sessions.

+ if:
  You want FUTON1 to support both offline corpus ingestion and interactive
  exploration, with both surfaces reading from and writing to the same XTDB
  state in a predictable way.

+ however:
  Ingest currently operates as a standalone CLI with limited guidance on how
  its outputs integrate with the demo/client view of the world. Directory
  conventions, expected data-root layouts, and test coverage for ingest
  semantics (ID stability, relation structure, negation handling) are not yet
  consolidated.

+ then:
  Define a standard data-root layout for ingest and demo/client workflows,
  document how ingest-produced XTDB documents appear in the hydrated store,
  and provide small example workflows that ingest a text sample and then query
  the resulting state through the demo/client or API surfaces. Add a minimal
  set of golden tests covering entity-ID stability and relation formation.

+ because:
  When ingest and interactive exploration share a clear, documented storage
  path, FUTON1 can accumulate durable background knowledge in a controlled
  way. This makes the persistent world state coherent across offline and
  online workflows and maintains determinism across restarts.

+ evidence:
  - README confirms deterministic ingest via CoreNLP and XTDB mirroring.
  - Demo/client workflows hydrate from XTDB on startup and therefore can read
    ingest-produced documents.
  - Existing golden fixtures demonstrate deterministic behaviour in other
    pipeline components.

+ next:
  Document shared data-root conventions; provide an ingest‚Üíquery example in
  the README; and implement golden tests for ingest ID stability and relation
  structure.

+ next-evidence:
  - A worked example showing ingest followed by demo/client queries against
    the same XTDB store.
  - Golden tests verifying stable entity IDs and relation outputs for a fixed
    input.
  - README updates linking ingest workflows to the persistent world model.

! pending: Prototype 4 ‚Äî NLP Experiments & Traceable Knowledge Graphs [üå±/Ëµ∑ üß™/Á≠π]

+ context:
  The new CLI tracer (`scripts/demo_trace.clj`) and API tap listener (`api.analytics/start!`) produce
  structured focus-header and profile payloads for every turn. These traces make NLP regressions
  visible and allow us to reconstruct session-specific ER graphs outside XTDB.

+ if:
  You want to compare alternative recognisers or mathematical-text pipelines against the deterministic
  substrate, or you want to convert Tatami/demo sessions into inspectable knowledge graphs without
  mutating production storage.

+ however:
  Tatami tracing is still manual, and there is no tooling yet to turn the tap payloads into graph
  artifacts. Ideas for richer NLP experiments are not yet captured in this devmap.

+ then:
  Extend the headless API/tatami flow with the same tap logging as the demo tracer, document the
  planned NLP experiments here, and build a small exporter that reads trace EDNs + tap events and
  emits a consolidated entity/relation snapshot per session.

+ because:
  Consistent traces across CLI and API let FUTON1 evaluate NLP changes deterministically and produce
  reusable ‚Äúknowledge graph‚Äù snapshots per session. Recording these plans keeps the work visible
  without derailing core storage duties.

+ next:
  - Add an opt-in tap sink to the API/Tatami pipeline so live sessions populate `~/code/storage/futon1-
    traces/<session>/` just like the demo tracer.
  - Write an ER graph exporter that ingests those traces and produces a summary artifact (EDN/Graphviz)
    for analysis.
  - Catalogue candidate NLP experiments (alternate recognisers, mathematical text ingestion, scoring
    heuristics) and their evaluation criteria in this devmap.

+ next-evidence:
  - Trace directories containing both CLI and Tatami sessions.
  - ER graph export script plus sample output checked into `resources/` or `docs/`.
  - devmap entries describing the queued NLP experiments and how their results will be judged.

! instantiated-by: Prototype 6 ‚Äî Thematic Clusters & Intent Metadata [üôÖ/Êó† üöû/Âä≤]

+ context:
  FUTON1 can attach lightweight thematic tags to utterances or text spans
  during ingest or interactive use. These tags‚Äîderived from deterministic NLP
  features or simple pattern-recognition hooks‚Äîprovide a minimal layer of
  ‚Äúintent metadata‚Äù that downstream futons may use for analysis or policy.

+ if:
  You want FUTON1 to expose a small, deterministic set of thematic categories
  that describe common conversational moves or content types, without relying
  on probabilistic classifiers or embedding higher-level inference in this
  layer.

+ however:
  There is no consolidated thematic taxonomy, the tags used in logs are not
  documented as part of the public contract, and no examples show how these
  tags appear in the stored XTDB documents or hydrated in-memory state.
  Integration points within demo/client or ingest workflows remain implicit.

+ then:
  Define a minimal set of thematic clusters supported by deterministic NLP
  features, document them as part of FUTON1‚Äôs public contract, and ensure that
  produced tags (when enabled) appear predictably in both in-memory and XTDB
  representations. Provide a small set of example workflows illustrating how
  these tags are attached during ingest or interaction and how they can be
  queried or inspected.

+ because:
  Lightweight thematic metadata strengthens FUTON1‚Äôs role as an inspectable
  storage substrate. By keeping the taxonomy small and deterministic, FUTON1
  avoids embedding inference or policy while still providing structured signals
  that higher futons may use for reasoning or pattern-based behaviour.

+ evidence:
  - README confirms deterministic NLP and pattern-recognition hooks.
  - Logs produced by demo/client workflows already contain descriptive
    metadata for some utterances.
  - XTDB persistence and hydration ensure that any added metadata can be made
    durable and inspectable.

+ next:
  Specify a small, deterministic thematic taxonomy; document how tags appear in
  FUTON1 outputs; and add examples showing ingestion or interaction annotated
  with these clusters.

+ next-evidence:
  - Updated README describing thematic clusters and their data shapes.
  - Deterministic tests verifying tag presence and structure.
  - Example ingest‚Üíquery or demo/client transcripts showing how tags persist.

! instantiated-by: Prototype 7 ‚Äî CLI Ergonomics & Multi-Instance Isolation [üéè/ËµÑÊñô üî¶/‰∫í]

+ context:
  The demo/client workflow exposes bang commands, flags, and environment
  variables for selecting data directories, overriding XTDB configuration, and
  controlling persistence behaviour. These surfaces already allow multiple
  instances of FUTON1 to run side-by-side on the same machine.

+ if:
  You want developers and tools to run isolated demo/client or API sessions
  for testing, experimentation, or production-like scenarios without
  interfering with each other‚Äôs storage or configuration.

+ however:
  Best practices for using `BASIC_CHAT_DATA_DIR`, XTDB resource overrides,
  `config.edn`, and reset/compact/export options are spread across READMEs and
  command-line examples. It is easy to misconfigure data roots or XTDB paths,
  and no single reference describes the recommended conventions for running
  multiple instances safely.

+ then:
  Document a small set of configuration patterns (e.g., dev/test/prod data
  roots), clarify how env vars and config.edn interact, and provide brief
  examples of running multiple isolated instances. Add smoke tests that launch
  separate demo/client or API sessions with distinct data roots. Include a
  simple `/status` helper or equivalent CLI flag that reports the active
  configuration.

+ because:
  Clear ergonomics and isolation practices make FUTON1 safer to embed in
  tooling and CI workflows, reduce accidental data mixing, and strengthen the
  determinism and reproducibility guarantees laid out in FUTON1‚Äôs IFR.

+ evidence:
  - README documents environment overrides, config.edn usage, and the
    structure of XTDB data directories.
  - Demo/client and API workflows can already be run with separate data roots.
  - XTDB instances behave independently when configured with distinct paths.

+ next:
  Provide documented configuration patterns, add isolation-oriented smoke
  tests, and implement a `/status` helper that surfaces the active config.

+ next-evidence:
  - A README section showing dev/test/prod data-root conventions.
  - Automated smoke tests confirming independent operation of concurrent
    instances.
  - A `/status` output (CLI or API) showing current data-root and XTDB config.

! instantiated-by: Prototype 8 ‚Äî Golden Scripts & Determinism Checks [üêú/‰∏çË¶Å üèÉ/commit]

+ context:
  FUTON1 already uses scripted EDN conversations and golden outputs to verify
  deterministic behaviour in the demo/client workflow, the NLP interface, and
  graph-memory operations. These fixtures ensure that focus-header formation,
  XTDB hydration, and pipeline flow remain stable across revisions.

+ if:
  You want confidence that changes to FUTON1 do not introduce regressions in
  determinism, header structure, or end-to-end behaviour, and that core
  workflows continue to perform within reasonable runtime bounds.

+ however:
  Golden coverage remains incomplete. Existing fixtures focus on specific
  modules rather than end-to-end flows, and there is no consolidated suite
  capturing short conversational runs, longer histories, or ingest-driven
  scenarios. Runtime behaviour is observable but not yet checked in a
  structured way.

+ then:
  Curate a small suite of canonical golden scripts that exercise representative
  workflows: a short demo/client session, a longer session with history, and a
  minimal ingest‚Üíquery example. Record their expected outputs and basic runtime
  characteristics, and run them under CI so deviations in XTDB state,
  focus-header structure, or runtime ranges are immediately visible.

+ because:
  A compact, well-chosen golden suite makes FUTON1‚Äôs determinism guarantees
  explicit, stabilises expectations about performance, and turns the substrate
  into a measurable layer rather than an informal demonstration.

+ evidence:
  - README documents deterministic behaviour, hydration patterns, and golden
    fixtures already present in module tests.
  - NLP and graph-memory test runners use scripted inputs and expected outputs.
  - XTDB inspection tooling (`-M:storage/inspect`) demonstrates reproducible
    state across runs.

+ next:
  Assemble the canonical golden suite, add runtime checks under CI, and link
  the suite from the top-level README as FUTON1‚Äôs determinism reference.

+ next-evidence:
  - A small directory containing canonical scripts and their expected outputs.
  - CI jobs reporting on determinism and basic runtime stability.
  - README references explaining how to run and interpret the golden suite.


! instantiated-by: Prototype 9 ‚Äî External Client & API Contract Clarification [üìÅ/Êó† üí§/‰π¶]

+ context:
  FUTON1 already exposes an HTTP API (`apps/api`) that lets external tools
  query and update the persistent store through the same command-service logic
  used by the demo/client workflow. This provides a minimal surface for
  submitting utterances, inspecting state, and retrieving deterministic
  summaries such as focus headers.

+ if:
  You want external clients to interact with FUTON1 without scraping CLI
  output or depending on internal modules, and to rely on a stable,
  documented interface for obtaining focus-header data and querying the
  underlying graph.

+ however:
  The available endpoints and their expected inputs and outputs are documented
  across several READMEs rather than in a single reference, and there are no
  minimal example clients showing how to issue requests and interpret the
  deterministic responses. The boundary between FUTON1‚Äôs API and higher-level
  agent behaviour remains implicit.

+ then:
  Consolidate FUTON1‚Äôs HTTP API contract: document the endpoints, describe
  the structure of request and response bodies (including focus headers), and
  provide one or two minimal example clients that demonstrate how to submit
  an utterance and inspect the resulting state. Keep the API minimal and
  deterministic, leaving policy or agent behaviour to higher futons.

+ because:
  A clear, documented API surface allows external tools to rely on FUTON1‚Äôs
  deterministic storage and summarisation behaviour without embedding
  orchestration logic. This strengthens FUTON1‚Äôs role as a stable substrate
  while avoiding scope creep into agent design or protocol negotiation.

+ evidence:
  - README documents the existence of the HTTP API and describes how to start
    it and configure its datastore.
  - Focus headers and entity summaries are already emitted by the same
    command-service used by the API.
  - XTDB-backed state is stable and consistent across CLI and API surfaces.

+ next:
  Produce a concise API contract, document the shape of focus-header
  responses, and include minimal example clients demonstrating deterministic
  interaction.

+ next-evidence:
  - A single API reference file enumerating endpoints and data shapes.
  - Sample clients (Clojure and one other language) communicating with the API.
  - CI tests confirming that responses remain stable across versions.
  - **Clients that omit profile configuration correctly resolve to the
    documented default profile, and the `/status` surface shows the resolved
    datastore path.**

! instantiated-by: Prototype 10 ‚Äî World-State Access & Storage Model Documentation [üíñ/Â∑≤ üë≠/ÊÖã]

+ context:
  FUTON1 maintains the canonical world state for the stack through its combined
  Datascript and XTDB representation. Downstream tools‚Äîwhether FUTON4, Arxana,
  Emacs interfaces, or ad-hoc scripts‚Äîneed a clear understanding of how this
  state is structured and how to retrieve entities, relations, salience fields,
  and other stored documents without relying on internal assumptions.

+ if:
  You want any external consumer to be able to inspect FUTON1‚Äôs world state
  deterministically, using documented queries and data shapes rather than
  reverse-engineering internal code paths or storage conventions.

+ however:
  Although the README describes persistence and hydration behaviour, there is
  no consolidated description of the storage model: which document types exist,
  how entities and relations are shaped in XTDB, how salience metadata is
  encoded, or which example queries reliably retrieve these structures. Export
  options exist, but no single reference explains their intended use.

+ then:
  Publish a concise storage-model reference that defines FUTON1‚Äôs persisted
  document types, key fields, and their relationships. Provide example XTDB and
  Datascript queries for retrieving entities, relations, salience metadata, and
  type information. Illustrate how downstream tools can consume this world
  state without depending on internal module boundaries.

+ because:
  A clear storage-model contract makes FUTON1 a dependable foundation for the
  rest of the FUTON stack. It allows external tools to read and reason over the
  same durable world state without special-case integrations or export modes,
  preserving determinism and reducing the risk of accidental divergence.

+ evidence:
  - README documents XTDB hydration, document structure, and the relationship
    between XT persistence and Datascript caching.
  - XT inspection workflows (`-M:storage/inspect`) already expose entity and
    relation documents.
  - Demo/client workflows and ingest pipelines both write into the same store.

+ next:
  Produce a dedicated storage-model reference; add example XTDB and Datascript
  queries; and clarify how exported snapshots or raw XTDB directories may be
  consumed by external tools.

+ next-evidence:
  - A single document outlining document types, field semantics, and example
    queries.
  - Tests confirming that example queries return stable shapes across versions.
  - README or doc links showing how external tools can load and inspect the
    world state.

! instantiated-by: Prototype 11 ‚Äî Reproducible Pilot Workflows [üë≠/Êâç üêú/Á®ã]

+ context:
  Users may wish to construct small pilot workflows‚Äîcombining ingest,
  demo/client interaction, and the persistent world state‚Äîto explore ideas,
  test downstream reasoning layers, or run controlled experiments. FUTON1 does
  not run these pilots itself, but provides the deterministic substrate they
  depend on.

+ if:
  You want FUTON1 to support reproducible, user-defined pilot scenarios for
  experimental, investigative, or research-oriented purposes, without
  embedding pilot logic or inference in this layer.

+ however:
  There is no standard way to package a pilot‚Äôs configuration, transcripts,
  and expected XTDB state. Any existing examples are informal or private, and
  users who attempt to replay scenarios must reconstruct them manually from
  multiple surfaces.

+ then:
  Document how to assemble a minimal reproducible pilot using FUTON1‚Äôs
  existing tools: define a data-root, record transcripts, capture expected
  outputs, and describe how to reload and inspect the resulting world state
  using the CLI, API, and XTDB inspection functions. Provide a small example
  illustrating this workflow.

+ because:
  Experimental and reasoning-oriented futons (e.g., FUTON2, FUTON4, FUTON5)
  require a stable, deterministic backend for storing and replaying world
  state. By documenting how pilots can rely on FUTON1‚Äôs storage and hydration
  guarantees, FUTON1 supports reproducible experimentation without expanding
  its own scope.

+ evidence:
  - FUTON1 already supports deterministic transcripts and XTDB-backed
    persistence across sessions.
  - CLI and API surfaces can drive scripted workflows without modification.
  - XTDB inspection paths allow deterministic verification of stored state.

+ next:
  Produce a short guide for assembling and replaying a reproducible pilot using
  FUTON1; include a small worked example.

+ next-evidence:
  - A minimal pilot example containing configuration, transcripts, and
    expected XTDB state.
  - README references describing how external futons can use such pilots as
    test fixtures or experimental scaffolds.

! instantiated-by: Prototype 12 ‚Äî Consolidation & Packaging Pass [üåΩ/Êú´ üë¥/Áî≥]

+ context:
  As FUTON1 evolves, its modules, configuration surfaces, and documentation
  accumulate incremental changes. Over time this can introduce small
  inconsistencies across apps, flags, environment variables, or test and build
  workflows. A periodic consolidation pass helps restore coherence without
  changing FUTON1‚Äôs scope.

+ if:
  You want FUTON1 to remain easy to install, run, understand, and extend by
  others‚Äîincluding tools and futons that depend on it‚Äîwithout requiring
  context from its development history.

+ however:
  Naming and configuration conventions have drifted across modules, some flags
  and env vars are documented in multiple places, and not all apps follow the
  same patterns for logging, error handling, or test invocation. These
  divergences do not break functionality but reduce predictability.

+ then:
  Perform a consolidation pass: unify naming and configuration across
  modules; align build and test tasks; and produce a top-level README or guide
  that gives a single, coherent account of FUTON1‚Äôs structure, installation
  prerequisites, and usage patterns.

+ because:
  A coherent packaging of FUTON1 strengthens its role as the dependable base
  layer for higher futons and for collaborators who rely on deterministic
  behaviour but may not know the internal architecture. Clear organisation
  reduces friction, supports reproducibility, and makes FUTON1 easier to
  maintain as a stable substrate.

+ evidence:
  - Existing READMEs document modules and workflows but vary in depth and
    structure.
  - Test and build commands differ across `apps/`.
  - Environment-variable usage appears in multiple places with minor
    variations.

+ next:
  Align naming and configuration; streamline build and test tasks; and publish
  a unified top-level reference document.

+ next-evidence:
  - Consistent flag and env-var naming across modules.
  - A shared build/test pattern verified by CI.
  - A single top-level README describing installation, configuration, and
    usage without cross-referencing scattered documents.
