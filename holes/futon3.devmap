@multiarg futon3/devmap
@title FUTON3 Development Map
@audience futon-devs, sandbox-agents, future-you
@tone formal-analytic
@style roadmap
@allow-new-claims true
@length any
@factor Joy / Rapture (pÄ«ti)
@IFR: FUTON3 is the place where the system turns messy activity into organised knowledge.
It collects what happens, checks it against a library of shared patterns, and produces clear, trustworthy records that other futons can use to learn, improve, and act.  FUTON3 makes everyday work auditable, meaningful, and easier to build on.

@state Transport runs reliably, events are logged, patterns can be checked, and Tatami sessions already feed structured evidence into the system. We have an early pattern catalog, working embeddings, and a first version of the workday pipeline. What remains is strengthening these links â€” tying checks into storage, producing clearer histories, and building the stable interfaces that other futons can depend on for coordinated reasoning.

@next Stand up the completed pattern canon + `check!` API, standardise proofâ†’graph/energy exports, and land the workday instrumentation + trail rollups as first-class MUSN services before expanding the flexiformal training ground.

! instantiated-by: Prototype 0 â€” Flexiformal Transport Baseline [ğŸ’¤/å·²]
  + context: FUTON3 still rides the MUSN transport (WS+HTTP bus, SAFE/ADMIN REPL, NDJSON ingest), but its primary job is to host pattern checks and informal proof states, not free-roaming agents.
  + if: You want an execution substrate where pattern obligations can be posed, evaluated, and recorded with deterministic transcripts.
  + however: The baseline hello/event/session flows are documented as â€œsandbox triviaâ€ instead of â€œproofwork IO contracts.â€
  + then: Freeze the transport contract from the perspective of check jobs (pattern-apply, gap-report, trail-capture), provide golden transcripts for each, and version the `sandbox` profile as the canonical proofwork runtime.
  + because: Flexiformal checking needs a stable log format before any higher-layer reasoning can rely on it.
  + evidence: docs/protocol.md, src/f2/router.clj, test/f2/router_test.clj.

! instantiated-by: Prototype 1 â€” Pattern Canon & Standard Library [ğŸ’–/æœ¬ ğŸ™…/åœ¨]
  + context: A small flexiarg/pattern library already exists (Nonstarter, Proto/Allow-Works, etc.) but is scattered between files.
  + if: You want FUTON3 to be the place where patterns are curated with metadata, linking obligations, and proof status.
  + however: There is no canonical store or schema for â€œpattern definitions + applicability notes + links to Futon devmaps.â€
  + then: Stand up a `f3.patterns` store (ID, clauses, references, pÄramitÄ tags, fruits/orbs weights) populated with the current standard library and backfilled with source links.
  + because: Without a canonical pattern store, the checker has nothing trustworthy to compare against.
  + evidence: `resources/pattern_store.edn`, `src/futon3/pattern_store.clj`, and `test/pattern_store_test.clj` keep the catalog synced with live tests + README references.

! instantiated-by: Prototype 2 â€” Similarity Field & Fake Embedding [ğŸ’¤/ä¹ ]
  + context: We already use a â€œfake embeddingâ€ (sigil adjacency) to find nearby patterns.
  + if: You want reproducible neighbourhood queries for pattern suggestions.
  + however: The embedding lives in ad-hoc CSVs and isnâ€™t wired into FUTON3â€™s APIs.
  + then: Integrate the sigil-distance matrix into FUTON3 as a first-class service (pattern search API, `nearest-patterns` command, CLI/UI views) and publish tests proving deterministic neighbourhoods.
  + because: Pattern suggestion quality underpins the flexiformal workflow and must be inspectable.

! instantiated-by: Prototype 3 â€” Applicability Engine & Check DSL [ğŸ‘/ä¹ˆ ğŸ’–/ä»€ä¹ˆ]
  + context: We want FUTON3 to answer â€œcan this pattern apply?â€ and â€œwhat new obligations arise?â€
  + if: You want a declarative DSL (possibly REPL-safe) for posing check contexts and receiving structured verdicts (applies / blocked / missing evidence).
  + however: Checks today are conversational heuristics in aob-chatgpt or handwritten flexiargs.
  + then: Define a `check!` API (inputs: pattern ID, context EDN, evidence refs; outputs: status, missing fields, derived tasks), enforce schema validation, and log every check as a proof state record.
  + because: Turning patterns into executable checks is what makes FUTON3 â€œflexiformalâ€ rather than just narrative.
  + next: Ship the Futon1/Futon2 adapters so `futon3/logs/checks.edn` entries replicate into graph + viriya stores instead of living only in local logs, and expose `/musn/check` over HTTP once the transport contract is frozen.
  + evidence: `src/futon3/checks.clj`, `src/f2/router.clj`, and `test/transport_test.clj` (check route cases) exercise the DSL end-to-end.

! instantiated-by: Prototype 4 â€” Trail & Proof-State Journal [ğŸ’–/å‡  ğŸ’–/å¼“]
  + context: Wisdom trails already exist for tracing exploration, but now they must document proof obligations and how work sessions discharged them.
  + if: You want every check, dismissal, and new pattern idea to leave an auditable trail.
  + however: Trails are still general-purpose exploration logs, not proof-state journals.
  + then: Extend the trail schema with `:pattern/id`, `:obligation/id`, `:action/tags`, and `:delta/joy`, add rollups that show which devmap clauses advanced per day, and expose a `/musn/trails/proof` export for futon4 archives.
  + because: The whole point is to measure how daily practice advances the devmaps.
  + design: The Tatami HUD cue-reflection pattern mirrors every FROM-CHATGPT entry back through `/musn/cues` so fruits/orbs in the HUD match the transportâ€™s cue embedding (`contrib/aob-chatgpt.el:1503`, `src/f2/ui.clj:97`, `src/futon3/cue_embedding.clj:214`).
  + evidence: `resources/tatami-events.edn` captures live tatami sessions, `resources/tatami-context.edn` logs every FROM-CHATGPT-EDN HUD payload, and the cue embedding tests (`test/futon3/cue_embedding_test.clj`) prove keyword/intentionally-null payloads round-trip.
  + blocked-by [:trail/persistence :cue-validation]
  + next: (1) persist cue annotations into the trail export so Prototypeâ€¯4 records which fruits/orbs were actually computed, and (2) add proof artifacts (HUD screenshots or `/musn/cues` transcripts) that demonstrate the cues signal real changes instead of static defaults before declaring the prototype stable.

! instantiated-by: Prototype 4b â€” Intent Embedding & Salience Map [ğŸ’¡/å‡  ğŸ’¡/å¼“]
  + context: Prototype 4 turns trails into proof-state journals, but it still treats fruits/orbs as cosmetic tags instead of Kolmogorov-style proof types for each constructive step.
  + if: You want the HUD to say not just â€œsomething happened hereâ€ but â€œthis was an indicator check, and it was (or wasnâ€™t) aligned with your valuesâ€ â€” i.e. to classify `intent â†’ pattern reasoning` as typed proof steps like ğŸŒâ†’ğŸ”µ rather than anonymous log lines.
  + however: The current trail schema records `:pattern/id` and `:obligation/id` but has no machinery to interpret `intent â†’ pattern reasoning` as a constructive proof step, embed it in fruit/orb space, and ask â€œwhat kind of operator was this?â€ (fruit) and â€œwhat meta-property did it exhibit?â€ (orb) â€” e.g. â€œğŸŒ: indicator construction, ğŸ”µ: virtue-alignedâ€.
  + then: Define a futon3 embedding pipeline that maps each `:trail/intent` plus `:pattern/reasoning` tuple into a low-dimensional vector, projects that vector onto a (fruit, orb) pair understood as (operator-class, meta-property), and computes a `:rule/salience` score from structural, pragmatic, and reflective components; write `:fruit/id`, `:orb/id`, and `:rule/salience` back onto the trail events so Prototype 4 can roll up â€œwhich devmap clauses advanced, via which kinds of proof step (e.g. ğŸŒ indicator definition or check, ğŸ’ simple inference, ğŸŠ breakdown into a proof plan, etc.), and how strongly they matteredâ€ per day.
  + because: In Kolmogorovâ€™s sense, a proof is a construction of an object; here, each trail step is a constructive proof step that builds a pattern-typed object whose canonical form is its (fruit, orb) type. Typing steps like â€œğŸŒâ†’ğŸ”µâ€ lets you distinguish â€œthis is just a checkâ€ from â€œthis is an indicator that actually preserves the virtue invariant,â€ and salience separates merely valid rules from those that are central to your meta-theory in practice.
  + design: Implement `futon3.intent-embedding/intent->vec` to encode `:trail/intent` + `:pattern/reasoning` as a vector, `futon3.intent-embedding/vec->fruit+orb` to pick the nearest (fruit, orb) type under a basis where fruits encode proof operator classes (e.g. ğŸŒ = indicator/check, ğŸ = invariant-preserving step) and orbs encode meta-properties (e.g. ğŸ”µ = value-aligned / virtue-preserving, ğŸŸ  = boundary-discernment); define `futon3.intent-embedding/vec->salience` to combine geometric proximity to an â€œidealâ€ direction for each (fruit, orb) type with usage frequency and an optional reflective score. Extend the trail export with `:fruit/id`, `:orb/id`, `:rule/salience`, and add HUD affordances so Tatami can sort, filter, or highlight proof-state entries by their typed role (e.g. all ğŸŒâ†’ğŸ”µ value-aligned checks) instead of just by timestamp.
  + evidence: Early Cue Embedding tests (`test/futon3/cue_embedding_test.clj`) already show that keyword payloads round-trip through the embedding; hand-labelled fruit/orb assignments in `resources/paramita-grid.edn` provide a gold set for checking whether `vec->fruit+orb` recovers the expected operator/meta-property types on known patterns, including basic Komolgorov relations like â€œindicator-construction steps that should land in the ğŸ”µ virtue bandâ€.
  + next: (1) Generalise the existing cue embedding to operate on `:trail/intent` + `:pattern/reasoning` tuples and return (fruit, orb) as proof step types, (2) run a calibration pass over a small set of manually typed patterns to tune the fruit/orb basis and salience weights, ensuring that canonical relations like ğŸŒâ†’ğŸ”µ (â€œvalue-aligned indicator checksâ€) land in the intended region, and (3) wire the enriched trail export into Prototype 4â€™s rollups so devmap progress can be inspected as â€œwhich constructive proof-types actually fired today, how salient they were, and whether the checks that claimed to align with your values really did so in the embedding.â€

! instantiated-by: Prototype 5 â€” Workday Instrumentation & aob-chatgpt Bridge [ğŸ’–/å¼“ ğŸ‘¯/å‡ ]
  + context: Within `aob-chatgpt` we already experiment with reflecting on daily actions against devmap obligations.
  + if: You want FUTON3 to serve as the backend for those reflections.
  + however: There is no official API for submitting â€œworkday claims,â€ mapping them to patterns, or receiving verification feedback; roles of â€œworkday participantsâ€ and â€œinstrumentation stewardsâ€ are undefined.
  + then: Publish a `workday/submit` endpoint (inputs: timestamp, activity, evidence links), run it through the check DSL + embedding, respond with pattern hits/misses plus follow-up obligations, and name the actors explicitly (participants supply evidence; instrumentation stewards curate dashboards); integrate the same flow into the ChatGPT tooling.
  + because: This is how empowered action (â€œjoyâ€) becomes measurable proof progress and how role responsibilities stay legible.
  + next: Replace the temporary `futon3/logs/workday.edn` queue with a Futon1 persistence call (`workday->graph`) and add HTTP affordances + dashboards so instrumentation stewards can audit submissions without tailing logs.
  + evidence: Workday intake lives in `src/futon3/workday.clj` with coverage in `test/transport_test.clj` (workday submission) and README sections describing the API.

! instantiated-by: Prototype 6 â€” Pattern Creation Workbench [ğŸ“/å½“ ğŸš´/æ‰‹]
  + context: New patterns emerge from trails and devmap edits, but the capture is currently manual in futon4.
  + if: You want FUTON3 to draft candidate patterns/flexiargs from accumulated proof states.
  + however: Manual backlog in FUTON4 creates tension; there is no readiness window for when drafts are â€œhand-off ready.â€
  + then: Build a summariser that clusters trails, extracts hooks, and emits draft flexiarg blocks (IF/HOWEVER/THEN/BECAUSE) tagged with suggested pÄramitÄ, ready for futon4 editors, and declare readiness criteria (e.g., at least N supporting checks + steward review) so handoffs are predictable.
  + because: FUTON3 should not just consume the library; it should propose expansions grounded in lived work while signalling when drafts can be trusted.

! instantiated-by: Prototype 7 â€” Joy-as-Empowered-Action Metrics [ğŸ’–/å¼“ ğŸš´/åŠ›]
  + context: Joy here = Spinozan increase in power to act, evidenced by commitments you can now keep.
  + if: You want metrics that show whether checks are empowering or draining.
  + however: Current â€œjoy metricsâ€ counted UI friction; they did not measure proofs discharged or obligations unblocked.
  + then: Track `time-to-proof`, `obligations-cleared`, `follow-on commitments`, and `viriya linkages` per session, and visualise them alongside subjective notes.
  + because: Empowered action is the KPI for this futon.

! instantiated-by: Prototype 8 â€” futon2/futon1 Proof Hooks [ğŸ‘•/å½“ ğŸ’¤/å·²]
  + context: FUTON3 already generates proof states; FUTON1 (graph) and FUTON2 (energy) need those proofs as fuel.
  + if: You want every accepted check to become a graph relation and a viriya delta without manual glue.
  + however: today the exports are bespoke Clerk notebooks or one-off scripts.
  + then: standardise two adaptersâ€”`proof->graph` (materialise relations with provenance) and `proof->energy` (emit activation deltas for futon2 dashboards)â€”and lock them with fixtures + schemas.
  + because: proofs only matter when other futons can act on them automatically.
  + next: Wire the Tatami event log into FUTON1 (per `futon3/tatami_store.clj` TODO) so session events flow into graph-memory before we expose the adapters.

! instantiated-by: Prototype 9 â€” Proof Training Ground (â€œFlexiformal Agent Sandboxâ€) [ğŸ“/ä¹‰ ğŸ’—/é—¨]
  + context: FUTON3 needs a reproducible training ground where humans and agents can practice flexiformal checks before contributing to FUTON6.
  + if: You want collaborators (including FUTON6 math stewards) to experience the proof workflow hands-on.
  + however: README/docs still emphasise ants and MUD metaphors and do not ship a simulator/tutorial bundle; roles (training facilitators vs. FUTON6 learners) and release readiness are not declared.
  + then: Package a â€œFlexiformal Training Groundâ€ release: updated README, tutorials referencing `t4r/` training patterns, sample check sessions, and a minimal simulator that feeds FUTON6â€™s Hyperreal entries; name facilitators (FUTON3 maintainers) and consumers (FUTON6 trainees), and publish readiness criteria (tutorials complete, simulator recorded, onboarding docs updated) before tagging the release.
  + because: Storytelling plus an explicit training ground turns FUTON3 into a reproducible service that upstream layers (FUTON6, FUTON7) can consume and steward.
  + next: Aggregate Tatami session proof events into `proof-chain.edn` (per `tatami_store.clj` TODO) so the training ground exports persistent transcripts.
