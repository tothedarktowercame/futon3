#+TITLE: Fucodex Trial Mission Analysis (AIF Trace Evidence)

This document explains why the trial mission works, what it demonstrates, and
how the AIF layer fits into FuLab proofwork. Fill in the "Run evidence" section
after a real fucodex execution.

* Run evidence

Paste the returned proof map (or the `:check/aif-trace` block + timestamps +
session id) from the runbook execution here.

#+BEGIN_SRC clojure
;; Run on 2026-01-02T17:18:16.213Z via `aif/validate-aif-proof`.
{:pattern/id "mojo/west"
 :context "AIF episode with 3 ticks"
 :proof/status :applies
 :check/aif-trace {:g-mean 0.8000000000000002
                   :tau-range [0.2 0.5]
                   :action-counts {:observe 1 :act 1 :tune 1}
                   :constraint-violations ["pattern-constraint-failed@:act"]}}
#+END_SRC

* What the mission shows

The mission uses a tiny synthetic AIF episode trace to demonstrate:
- How Futon2-style step results can be summarized into a stable evidence map.
- How that evidence is attached to a Futon3 proof as `:check/aif-trace`.
- Why a "lossy" summary is still useful for inspection and drift checks.

* Why these fields matter

The AIF summary fields are chosen to capture behavior without storing every
step:
- `:g-mean` reflects average energy / desirability across the episode.
- `:tau-range` shows how confident or uncertain the policy was.
- `:action-counts` exposes behavioral balance (observe vs act, etc.).
- `:constraint-violations` captures any rule breaks for immediate inspection.

This is enough for a human to read a proof and know whether an episode behaved
roughly as expected, without opening a full trace viewer.

* How the bridge computes it

The AIF bridge (`src/futon3/aif_bridge.clj`) extracts these values directly from
the per-step trace, then builds a proof check request. That means the proof is
still produced by the normal `check!` pipeline, so it fits into the same proof
and obligation logic as other FuLab evidence.

In practical terms:
- Futon2 runs produce step traces.
- A summary is computed deterministically.
- Futon3 checks embed the summary so the proof is self-contained.

* How this fits a real workflow

In a real run, the AIF summary can be passed in a workday payload or a check
request. Example payload snippet:

#+BEGIN_SRC clojure
{:pattern/id "mojo/west"
 :context "AIF episode with 40 ticks"
 :aif-trace {:g-mean 0.842
             :tau-range [0.12 0.88]
             :action-counts {:observe 12 :act 4}}}
#+END_SRC

Futon3 then attaches this to the proof as `:check/aif-trace`, so proof consumers
can review the run without loading Futon2 logs. If you need the full trace,
keep it in Futon2 or your experiment log.

* Limits and next steps

This summary is not a replacement for deep analysis, only a bridge between the
AIF world and proof checks. If you need richer comparisons (e.g., distribution
drift across many runs), keep the detailed trace data in Futon2 and treat this
summary as the "headline" evidence for Futon3.
